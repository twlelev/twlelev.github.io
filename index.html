<!DOCTYPE html>


<html lang="zh-CN">
  

    <head>
      <meta charset="utf-8" />
        
      <meta name="description" content="用于记录学习笔记的个人网站" />
      
      <meta
        name="viewport"
        content="width=device-width, initial-scale=1, maximum-scale=1"
      />
      <title> twlelev的博客</title>
  <meta name="generator" content="hexo-theme-ayer">
      
      <link rel="shortcut icon" href="/favicon.ico" />
       
<link rel="stylesheet" href="/dist/main.css">

      
<link rel="stylesheet" href="/css/fonts/remixicon.css">

      
<link rel="stylesheet" href="/css/custom.css">
 
      <script src="https://cdn.staticfile.org/pace/1.2.4/pace.min.js"></script>
       
 

      <link
        rel="stylesheet"
        href="https://cdn.jsdelivr.net/npm/@sweetalert2/theme-bulma@5.0.1/bulma.min.css"
      />
      <script src="https://cdn.jsdelivr.net/npm/sweetalert2@11.0.19/dist/sweetalert2.min.js"></script>

      <!-- mermaid -->
      
      <style>
        .swal2-styled.swal2-confirm {
          font-size: 1.6rem;
        }
      </style>
    <link rel="stylesheet" href="/css/prism-tomorrow.css" type="text/css">
<link rel="stylesheet" href="/css/prism-line-numbers.css" type="text/css"></head>
  </html>
</html>


<body>
  <div id="app">
    
      
    <main class="content on">
      
<section class="cover">
    
  <div class="cover-frame">
    <div class="bg-box">
      <img src="/images/cat.jpg" alt="image frame" />
    </div>
    <div class="cover-inner text-center text-white">
      <h1><a href="/">twlelev的博客</a></h1>
      <div id="subtitle-box">
        
        <span id="subtitle"></span>
        
      </div>
      <div>
        
      </div>
    </div>
  </div>
  <div class="cover-learn-more">
    <a href="javascript:void(0)" class="anchor"><i class="ri-arrow-down-line"></i></a>
  </div>
</section>



<script src="https://cdn.staticfile.org/typed.js/2.0.12/typed.min.js"></script>


<!-- Subtitle -->

  <script>
    try {
      var typed = new Typed("#subtitle", {
        strings: ['不必在乎别人提前拥有', '学海无涯，学无止境', '愿你的努力都能得到回报'],
        startDelay: 0,
        typeSpeed: 200,
        loop: true,
        backSpeed: 100,
        showCursor: true
      });
    } catch (err) {
      console.log(err)
    }
  </script>
  
<div id="main">
  <section class="outer">
  
  
  

<div class="notice" style="margin-top:50px">
    <i class="ri-heart-fill"></i>
    <div class="notice-content" id="broad"></div>
</div>
<script type="text/javascript">
    fetch('https://v1.hitokoto.cn')
        .then(response => response.json())
        .then(data => {
            document.getElementById("broad").innerHTML = data.hitokoto;
        })
        .catch(console.error)
</script>

<style>
    .notice {
        padding: 20px;
        border: 1px dashed #e6e6e6;
        color: #969696;
        position: relative;
        display: inline-block;
        width: 100%;
        background: #fbfbfb50;
        border-radius: 10px;
    }

    .notice i {
        float: left;
        color: #999;
        font-size: 16px;
        padding-right: 10px;
        vertical-align: middle;
        margin-top: -2px;
    }

    .notice-content {
        display: initial;
        vertical-align: middle;
    }
</style>
  
  <article class="articles">
    
    
    
    
    <article
  id="post-视频编码/未命名"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2023/07/17/shi-pin-bian-ma/wei-ming-ming/"
    >视频编码基础</a> 
</h2>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/2023/07/17/shi-pin-bian-ma/wei-ming-ming/" class="article-date">
  <time datetime="2023-07-17T12:15:00.000Z" itemprop="datePublished">2023-07-17</time>
</a> 
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E8%A7%86%E9%A2%91%E7%BC%96%E7%A0%81%E5%9F%BA%E7%A1%80/">视频编码基础</a>
  </div>
   
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <h1 id="1-H-264"><a href="#1-H-264" class="headerlink" title="1.H.264"></a>1.H.264</h1><h2 id="A-ffmpeg入门"><a href="#A-ffmpeg入门" class="headerlink" title="A.ffmpeg入门"></a>A.ffmpeg入门</h2><h6 id="a-YUV文件格式"><a href="#a-YUV文件格式" class="headerlink" title="a.YUV文件格式"></a>a.YUV文件格式</h6><p>ffmpeg是一个开源免费跨平台的视频和音频流方案，它提供了录制、转换以及流化音视频的完整解决方案，其包含了非常先进的音频&#x2F;视频编解码库libavcodec.</p>
<p>YUV(Y’CbCr)是一种像素格式，见于视频编码与静态图像。与RGB格式不同，YUV分别由一个称为Y(相当于灰度)的“亮度”分量和两个称为U(蓝色投影)和V(红色投影)的“色度”分量表示。<br>若只有亮度分量而没有色度分量，即为黑白图片。</p>
<p>一般用Y, U, V三者的比率来表示不同格式。<br>YUV444表示三者比值是4:4:4,即一个数据点，Y, U, V的空间大小都是一样的。所有格式中Y比值都是4，占一个字节，表示没有减少采样，不同格式中，减少只是UV的采样值。</p>
<p>4:4:4 ：表示色度值（UV）没有减少采样，即Y, U, V各占一个字节，总共占3字节。</p>
<p>4:2:2 ：表示UV分量采样减半，比如第一个像素采样Y,U，第二个像素采样Y,V，依次类推，这样每个点招用两个字节。</p>
<p>4:2:0 ：这种采样并不意味着只有Y,Cb而没有Cr分量，而是U,V分量隔行才采样一次。<br>即[Y0,U0,V0],[Y1,U1,V1],[Y2,U2,V2],[Y3,U3,V3]<br>采样后变为[Y0,U0],[Y1],[Y2,V1],[Y3]<br>由4:4:4的一个像素3字节，变为平均1个像素1.5字节。</p>
<blockquote>
<p>ffmpeg库的接口都是c函数，在cpp文件里调用ffmpeg函数需要注意，因为c语言不支持函数重载，一个用C写成的库如果想被C&#x2F;C++同时可以使用，在头文件应该加上以下代码</p>
</blockquote>
<pre><code> #ifdef __cplusplus
  extern &quot;C&quot; &#123;
  #endif 
  ...
  #ifdef __cplusplus
  &#125;
  #endif
</code></pre>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E8%A7%86%E9%A2%91%E7%BC%96%E7%A0%81%E5%9F%BA%E7%A1%80/" rel="tag">视频编码基础</a></li></ul>

    </footer>
  </div>

   
   
  
</article>

    
    <article
  id="post-NCNN/ncnn"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2023/07/08/ncnn/ncnn/"
    >ncnn基础</a> 
</h2>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/2023/07/08/ncnn/ncnn/" class="article-date">
  <time datetime="2023-07-08T06:54:31.000Z" itemprop="datePublished">2023-07-08</time>
</a> 
  <div class="article-category">
    <a class="article-category-link" href="/categories/ncnn/">ncnn</a>
  </div>
   
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <h1 id="1-NCNN简介"><a href="#1-NCNN简介" class="headerlink" title="1.NCNN简介"></a>1.NCNN简介</h1><p>ncnn是一个为手机端极致优化的高性能神经网络前向计算框架。ncnn从设计之初深刻考虑手机端的部署和应用。无第三方依赖，跨平台，手机端cpu的速度快于快于目前所有已知的开源框架。基于ncnn，开发者能够将深度学习算法轻松移植到手机端高效执行，开发出人工智能APP。</p>
<h1 id="2-怎么使用？"><a href="#2-怎么使用？" class="headerlink" title="2.怎么使用？"></a>2.怎么使用？</h1><ul>
<li>git clone ncnn仓库(若需要gpu推理需要submodule)</li>
</ul>
<pre><code>git clone https://github.com/Tencent/ncnn.git
cd ncnn
git submodule update --init
</code></pre>
<ul>
<li>(option) 下载vulkan_sdk(gpu推理配置)</li>
</ul>
<pre><code>wget https://sdk.lunarg.com/sdk/download/1.2.189.0/linux/vulkansdk-linux-x86_64-1.2.189.0.tar.gz?Human=true -O vulkansdk-linux-x86_64-1.2.189.0.tar.gz
tar -xf vulkansdk-linux-x86_64-1.2.189.0.tar.gz
export VULKAN_SDK=$(pwd)/1.2.189.0/x86_64
</code></pre>
<ul>
<li>编译ncnn库</li>
</ul>
<pre><code>## gpu推理
cd ncnn
mkdir -p build
cd build
cmake -DCMAKE_BUILD_TYPE=Release -DCMAKE_TOOLCHAIN_FILE=../toolchains/jetson.toolchain.cmake -DNCNN_VULKAN=ON -DNCNN_BUILD_EXAMPLES=ON ..
make -j$(nproc)

## 若不需要gpu推理
cd ncnn
mkdir build
cd build
cmake .. &amp;&amp; make -j4
make install #可以生成头文件和链接库
</code></pre>
<ul>
<li>onnx转ncnn<br>在编译好的build的情况下，.&#x2F;build&#x2F;tools&#x2F;onnx里面的脚本文件onnx2ncnn即为转ncnn推理模型的脚本，将model.onnx转为model.param和model.bin.</li>
</ul>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/ncnn/" rel="tag">ncnn</a></li></ul>

    </footer>
  </div>

   
   
  
</article>

    
    <article
  id="post-c++/c++ 基础"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2023/04/27/c/c-ji-chu/"
    >c++基础</a> 
</h2>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/2023/04/27/c/c-ji-chu/" class="article-date">
  <time datetime="2023-04-27T02:15:31.000Z" itemprop="datePublished">2023-04-27</time>
</a> 
  <div class="article-category">
    <a class="article-category-link" href="/categories/c/">c++</a>
  </div>
   
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <h1 id="1-static-inline"><a href="#1-static-inline" class="headerlink" title="1.static inline"></a>1.static inline</h1><p>对于普通函数而言，在a.h中声明然后在a.cpp中定义，再经过编译链接后我们在test1.cpp、test2.cpp中就可以通过#include”a.h”来调用函数。但是对于内联函数而言，我们无法在test1.cpp、test2.cpp中同时通过#include”a.h”来调用内联函数，也就是说一个.h中的内联函数被两个不同的文件包含，则会出现重名，链接失效。但如果使用static inline可以解决<br>这个问题，使用static修饰符，函数仅在文件内部可见。可以理解为一个inline在不同的.C里面生成了不同的实例，而且名字是完全相同的。</p>
<h1 id="2-static"><a href="#2-static" class="headerlink" title="2.static"></a>2.static</h1><p><strong>static可以修饰哪些变量:</strong></p>
<p>全局静态变量、局部静态变量、函数，除此之外，还可以修饰类中的静态成员变量以及静态成员函数。<br>&#96;&#96;</p>
<blockquote>
<ul>
<li>全局静态变量和局部静态变量都存储在静态存储区。存储在静态存储区的变量在编译期完成初始化，static定义的局部变量也是在编译时期分配的，而且生存期是永久的，直到生存期结束。</li>
<li>静态成员函数不能访问普通成员变量，静态函数在编译期完成了初始化，而此时类还未初始化，此时访问了不存在的变量。</li>
<li>全局静态变量相对于全局变量而言，全局变量具有外部链接性，通过声明extern关键字可以进行变量的赋值。而全局静态变量不具有外部链接性。</li>
<li>类中对象之间的成员变量是相互独立的 ，想要共用数据需要使用静态成员或者静态方法。由前面所知，在类中定义的静态成员函数以及静态成员变量在编译期完成初始化，因此，即使不定义对象，静态成员变量存储在静态存储区，其已经分配了内存空间，其不随对象的创建而创建，也不随对象的消亡而消亡。</li>
<li>静态成员函数只能访问静态成员变量。</li>
</ul>
</blockquote>
<p><strong>举个static相关例子如下</strong>：</p>
<pre><code>class StaticA
&#123;
public:
    StaticA()&#123;&#125;;
    ~ StaticA()&#123;&#125;;
    static int a; //静态成员变量只能在类外初始化
    static int teststatic()
    &#123;
        std::cout&lt;&lt;&quot;a:&quot;&lt;&lt;a&lt;&lt;std::endl;
    &#125;
&#125;;
int StaticA::a=1;

int main()
&#123;
StaticA *A=nullptr;
A-&gt;teststatic(); // 输出 a:1
return 0;
&#125;
</code></pre>
<h1 id="3-vitual虚函数"><a href="#3-vitual虚函数" class="headerlink" title="3.vitual虚函数"></a>3.vitual虚函数</h1><h2 id="构造函数、析构函数之虚函数"><a href="#构造函数、析构函数之虚函数" class="headerlink" title="构造函数、析构函数之虚函数"></a>构造函数、析构函数之虚函数</h2><p><strong>构造函数不可以是虚函数，而析构函数常常是虚函数。</strong><br>构造函数不可以是虚函数，原因如下：</p>
<blockquote>
<p>虚函数的调用是通过虚函数表来调用的。而虚函数表是由实例化的vptr指针来指向的，该实例化指针存放在对象的内部空间中且占8字节，需要调用构造函数完成初始化。因此，虚函数的调用需要发生在构造函数之后。</p>
</blockquote>
<p>析构函数可以常常是虚函数，原因如下：</p>
<blockquote>
<p>在实现多态性时，通过基类去指向派生类对象，只有申明为虚函数才能实现。如果定义的派生类对象是基类类型时，若没有声明基类虚析构函数，派生类在调用析构函数时，则会调用基类的虚构函数，会存在内存泄漏的风险。</p>
</blockquote>
<h2 id="类成员函数之虚函数"><a href="#类成员函数之虚函数" class="headerlink" title="类成员函数之虚函数"></a>类成员函数之虚函数</h2><p>派生类需要重写基类中的同名函数，则需要在基类中声明virtual虚函数，否则是不允许的。</p>
<h3 id="补充：重载与重写区别："><a href="#补充：重载与重写区别：" class="headerlink" title="补充：重载与重写区别："></a>补充：重载与重写区别：</h3><p>C++中的重载（Overloading）和重写（Overriding）是两个不同的概念，它们之间有以下几个不同点：</p>
<blockquote>
<ul>
<li><strong>定义位置不同</strong>:<br>重载是在同一个类中定义多个具有相同名称但参数列表不同的函数，重载函数可以包括不同类型、不同数量、不同顺序的参数。而重写是在派生类中重新定义一个从基类中继承的已有函数，函数名称、参数列表和返回值类型在基类和派生类中必须完全相同。</li>
<li><strong>对象的处理不同</strong>:<br>重载函数是编译期多态，由编译器根据传入的参数类型和数量来决定调用哪个函数。而重写函数是运行期多态，由运行时的实际对象类型来决定调用哪个函数。</li>
<li><strong>可访问性不同</strong>:<br>如果一个成员函数用<code>virtual</code>关键字声明为虚函数，则它可以在派生类中被重写。如果在派生类中重写基类中非虚函数的函数，这是不允许的。由于访问非虚函数是通过编译时分辨多态来实现的，所以在编译时通过基类指针或引用调用派生类的函数会调用基类函数，而不会调用派生类中的同名函数。</li>
<li><strong>参数匹配和返回值类型</strong>:<br>重载函数和重写函数的参数匹配和返回值类型在调用时有着不同的表现。在重载函数中，函数调用的正确匹配由编译器通过参数类型和数量决定。在重写函数中，参数列表和返回值类型必须与基类中的函数完全匹配，否则会导致编译错误。</li>
</ul>
</blockquote>
<h1 id="4-RAII"><a href="#4-RAII" class="headerlink" title="4.RAII"></a>4.RAII</h1><p>RAII是C++中一种非常重要的编程思想，全称为Resource Acquisition Is Initialization，中文为“资源获取即初始化”。它主要是利用C++的构造函数在对象初始化时自动获取资源，并在对象析构时自动释放资源的特性进行对象封装，以方便管理和避免资源泄露。</p>
<pre><code>class MemoryBlock
&#123;
public:
MemoryBlock():_length(0),_data(nullptr)&#123;&#125;

MemoryBlock(size_t length):_length(length),_data(new char[length])
&#123;
    std::cout &lt;&lt; &quot;constructed!&quot; &lt;&lt;std::endl;
&#125;

~MemoryBlock()
&#123;
    delete[] _data ;
    std::cout &lt;&lt; &quot;destructed!&quot; &lt;&lt; std::endl;
&#125;

// 拷贝构造函数，实现深度拷贝
MemoryBlock(const MemoryBlock&amp; other):_length(other._length),_data(new char[other._length])
&#123;
    std::copy(other._data, other._data+_length, _data);
    std::cout&lt;&lt; &quot;deep copy constructed!&quot; &lt;&lt;std::endl;
&#125;

// 赋值运算符实现深度赋值
MemoryBlock&amp; operator=(const MemoryBlock&amp; other)
&#123;
    if(this != &amp;other)
    &#123;
        if(_data!= nullptr) delete[] _data;
        _length = other._length;
        _data = new char[_length];
        std::copy(other._data, other._data+_length, _data);
    &#125;
    return *this;
&#125;

size_t length()
&#123;
return _length;
&#125;

char* data()
&#123;
return _data;
&#125;

private:
size_t _length;
char *_data;
&#125;;

int main()
&#123;

    MemoryBlock memoryblock1(20);
    
    std::strcpy(memoryblock1.data(), &quot;Hello World!&quot;);
    
    std::cout &lt;&lt; &quot;memoryblock1: &quot; &lt;&lt; memoryblock1.data() &lt;&lt; std::endl;
        
    // 拷贝构造函数生成类对象
    
    MemoryBlock memoryblock2(memoryblock1);
    
    std::cout &lt;&lt; &quot;memoryblock2: &quot; &lt;&lt; memoryblock2.data() &lt;&lt; std::endl;
    
    // 赋值生成对象
    MemoryBlock memoryblock3;
    memoryblock3 = memoryblock1;
    std::cout &lt;&lt; &quot;memoryblock3: &quot; &lt;&lt; memoryblock3.data() &lt;&lt; std::endl;
&#125;
</code></pre>
<h1 id="5-override"><a href="#5-override" class="headerlink" title="5.override"></a>5.override</h1><p><code>override</code>是一个关键字，用于指示派生类中的虚函数将覆盖基类中的虚函数。它可以用于明确地指示编译器该函数是用于覆盖基类中的虚函数，如果不匹配则会导致编译错误。<br><strong>作用</strong>：<br>在于提高程序的可读性以及健壮性，在派生类中重写基类函数需要声明基类函数为虚函数，声明关键字<code>override</code> 可以告诉读者重写了基类中的虚函数。<br>就程序运行而言，<code>override</code>声明与否不会对程序运行有任何影响。</p>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/c/" rel="tag">c++</a></li></ul>

    </footer>
  </div>

   
   
  
</article>

    
    <article
  id="post-cuda/CUDA 编程简介"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2023/04/26/cuda/cuda-bian-cheng-jian-jie/"
    >cuda编程 简介</a> 
</h2>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/2023/04/26/cuda/cuda-bian-cheng-jian-jie/" class="article-date">
  <time datetime="2023-04-25T16:00:00.000Z" itemprop="datePublished">2023-04-26</time>
</a> 
  <div class="article-category">
    <a class="article-category-link" href="/categories/cuda/">cuda</a>
  </div>
   
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <h1 id="CUDA编程模型"><a href="#CUDA编程模型" class="headerlink" title="CUDA编程模型"></a>CUDA编程模型</h1><p>CUDA编程模型假设系统是由一个主机(CPU)和一个设备(GPU)组成的，而各自拥有独立的内存。因此，在CUDA编程中我们需要编写在设备(GPU)上运行的代码，也被称为核函数(Kernel)，其并行地运行在GPU的多个处理器上，这极大的提高了计算速度。</p>
<p>典型的CUDA程序执行步骤：</p>
<blockquote>
<ul>
<li>把数据从CPU内存拷贝到GPU内存。</li>
<li>调用核函数对存储在GPU内存中的数据进行操作。</li>
<li>将数据从GPU内存传回CPU内存。</li>
</ul>
</blockquote>
<p>CUDA编程模型的两个特点：<br>1.通过层次结构来组织线程</p>
<blockquote>
<ul>
<li>一般CPU一个核只支持一到两个硬件线程，而GPU在硬件层面就支持成百上千个并发线程。在CUDA编程中，线程是通过线程网格(Grid)、线程块(Block)、线程束(Warp)、线程(Thread)这几个层次管理。</li>
<li>由一个内核启动所产生的所有线程统称为一个网格(Grid),同一网格中的所有线程共享相同的全局内存空间。向下一级，一个网格由多个线程块(Block)构成。再下一级，一个线程块由一组线程(Thread)构成</li>
</ul>
</blockquote>
<p> 2.内存的使用</p>
<blockquote>
<ul>
<li>GPU中的各级缓存以及各种内存是可以软件控制的，这些内存包括寄存器、共享内存、常量内存、全局内存等。</li>
</ul>
</blockquote>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/cuda/" rel="tag">cuda</a></li></ul>

    </footer>
  </div>

   
   
  
</article>

    
    <article
  id="post-deeplearning"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2023/04/25/deeplearning/"
    >deeplearning</a> 
</h2>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/2023/04/25/deeplearning/" class="article-date">
  <time datetime="2023-04-24T16:00:00.000Z" itemprop="datePublished">2023-04-25</time>
</a> 
  <div class="article-category">
    <a class="article-category-link" href="/categories/deeplearning/">deeplearning</a>
  </div>
   
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><p><strong>球场位置坐标：</strong></p>
<p><img src="/./images/gfootball/gfootball_map.png" alt="avatar"></p>
<p><strong>球员动作：</strong><br><img src="/./images/gfootball/player_actions.png" alt="avatar"></p>
<h1 id="针对得分回报的稀疏性解决方案"><a href="#针对得分回报的稀疏性解决方案" class="headerlink" title="针对得分回报的稀疏性解决方案"></a>针对得分回报的稀疏性解决方案</h1><ol>
<li>通过scoring reward and checkpoint reward来实现(gfootball paper中有介绍)，大致思路就是给区域分块，当球的位置靠近goal,给予checkpoint reward.在早期的训练阶段，checkpoint reward是十分有效的，相当于给一个线索让智能体去得分(线索回报)。但是，checkpoint reward的缺点也是很明显：多样性受限，进攻方式比较单一，player更倾向于自己运球去得分。</li>
<li>通过监督学习学习一个具有一定得分能力的版本，在此基础上可只通过scoring reward来训练。</li>
</ol>
<h1 id="针对进攻方式单一，提高多样性解决方案"><a href="#针对进攻方式单一，提高多样性解决方案" class="headerlink" title="针对进攻方式单一，提高多样性解决方案"></a>针对进攻方式单一，提高多样性解决方案</h1><ol>
<li>在checkpoint reward训练好的模型上，通过selfplay training 继续训练，此时reward仅仅只有scoring reward(目的是探索更多能得分的行为)。因为训练好的模型已经拥有一定的得分能力，此时的得分回报已经不再稀疏。</li>
<li>从零开始Selfplay training + opponent pool+checkpointreward，因为gfootball env环境比较单一，selfplay training每通过一定的训练代数保存一个模型，因此逐步提升的模型具有多样性 。因此，随机选择保存的模型作为opponent，可解决gfootball env 环境单一问题。</li>
<li>通过reward shaping来塑性不同的智能体，例如：持球进攻性，边路进攻性，中路进攻性等，放在opponent pool中来作为对手提高多样性。</li>
</ol>
<h1 id="目前存在的问题以及可以优化的地方"><a href="#目前存在的问题以及可以优化的地方" class="headerlink" title="目前存在的问题以及可以优化的地方"></a>目前存在的问题以及可以优化的地方</h1><ol>
<li>action blocking 存在问题，因为blocking是根据ball_owned_team来判断，当ball_owned_team&#x3D;-1,即球不属于任何一方的时候，可能我们的action仍然属于踢球状态。因此，在使用action blocking后，动作不会那么流畅，而且球员传球后也得有停球动作才能进行传球。</li>
<li>具有观赏性的动作比较少，比如通过slide抢球，不仅具有观赏性，而且防守也比较高效；pass-&gt; shot(即A传球给B后立马shot，没有停球动作)也比较少。</li>
<li>2rd place的state dims为749(Fig1)，且仅采用fully-connected,而目前的state dims仅    为220。(就目前自己调研的结果来看，ML 添加更大的state dims有助于帮助收敛)。在监督学习中即使训练过拟合也没有关系。<img src="/./images/gfootball/2rd_observation_state_dims.png" alt="avatar"></li>
</ol>
<h1 id="selfplay-训练策略"><a href="#selfplay-训练策略" class="headerlink" title="selfplay 训练策略"></a>selfplay 训练策略</h1><p>selfplay训练模式的思路是：通过checkpoint reward+score reward两者回报相加来得到总的回报。训练的对手不再是基于规则的AI,对手刚开始没有任何得分能力，但随着我们训练的模型保存在模型池里面，训练的对手会从模型池里面载入模型（即训练的对手逐步变强）。</p>
<pre><code>&quot;latest_ratio&quot;: 0.5,             # works only for self_play training.
&quot;latest_n_model&quot;: 10,            # works only for self_play training.
</code></pre>
<p>上图的参数代表的意义：对手的模型以0.5的概率选择模型池里面最新更新的10个模型。</p>
<p>模型保存的间隔参数配置如下：</p>
<pre><code>&quot;model_save_interval&quot;: 300000,
</code></pre>
<p>Selfplay从0开始训练，大概保存300个模型性能机会不会再有提升了。</p>
<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p>各个队伍解决方案：<br><a target="_blank" rel="noopener" href="https://www.kaggle.com/competitions/google-football/discussion/204645">https://www.kaggle.com/competitions/google-football/discussion/204645</a></p>
<h1 id="下面视频为通过RL技术训练出来的控制游戏角色视频"><a href="#下面视频为通过RL技术训练出来的控制游戏角色视频" class="headerlink" title="下面视频为通过RL技术训练出来的控制游戏角色视频"></a>下面视频为通过RL技术训练出来的控制游戏角色视频</h1><div align="center"><video  width = "1048" heigt="700" id="video" controls >
      <source id="mp4" src="/videos/score_rl.mp4" type="video/mp4">
</video></div>

 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/gfootball/" rel="tag">gfootball</a></li></ul>

    </footer>
  </div>

   
   
  
</article>

    
    <article
  id="post-hexo 简介"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2023/04/21/hexo-jian-jie/"
    >hexo 简介</a> 
</h2>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/2023/04/21/hexo-jian-jie/" class="article-date">
  <time datetime="2023-04-20T16:00:00.000Z" itemprop="datePublished">2023-04-21</time>
</a> 
  <div class="article-category">
    <a class="article-category-link" href="/categories/hexo/">hexo</a>
  </div>
   
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <h1 id="1-什么是Hexo"><a href="#1-什么是Hexo" class="headerlink" title="1.什么是Hexo?"></a>1.什么是Hexo?</h1><p>Hexo是一个快速、简洁且高效的静态博客框架，使用Node.js编写，支持Markdown语法和EJS模板引擎。</p>
<h1 id="2-Hexo常用命令"><a href="#2-Hexo常用命令" class="headerlink" title="2.Hexo常用命令"></a>2.Hexo常用命令</h1><blockquote>
<ul>
<li>hexo clean：清除缓存文件</li>
<li>hexo g: 生成静态文件，即将Markdown文件生成为HTML文件。</li>
<li>hexo s: 启动本地服务器，用于本地浏览。</li>
<li>hexo d: 部署博客，将静态文件上传到远程服务器或者GitHub Pages.</li>
<li>hexo new post “article”: 新建一篇名为article的文章。</li>
<li>hexo new page “title”: 用于新建一个空的页面，相当于生成一个文件夹并在文件夹里面有一个初始md文件。</li>
<li>hexo init：新建博客，相当于初始化一个Hexo博客demo，需要空文件夹下执行该命令。</li>
</ul>
</blockquote>
<h1 id="3-简述Hexo构建流程"><a href="#3-简述Hexo构建流程" class="headerlink" title="3.简述Hexo构建流程"></a>3.简述Hexo构建流程</h1><p>该部分只对hexo搭建个人博客所需环境以及步骤列个目录，具体详情参见<a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/35668237">这里</a>。</p>
<h3 id="所需环境与步骤"><a href="#所需环境与步骤" class="headerlink" title="所需环境与步骤"></a>所需环境与步骤</h3><blockquote>
<ul>
<li>安装Node.js</li>
<li>安装Git</li>
<li>注册Github账号</li>
<li>安装Hexo</li>
<li>连接Github与本地</li>
</ul>
</blockquote>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/hexo/" rel="tag">hexo</a></li></ul>

    </footer>
  </div>

   
   
  
</article>

    
    <article
  id="post-git/git commit 规范"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2023/04/17/git/git-commit-gui-fan/"
    >git commit 规范</a> 
</h2>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/2023/04/17/git/git-commit-gui-fan/" class="article-date">
  <time datetime="2023-04-17T02:15:31.000Z" itemprop="datePublished">2023-04-17</time>
</a> 
  <div class="article-category">
    <a class="article-category-link" href="/categories/git/">git</a>
  </div>
   
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <h1 id="commit-message格式"><a href="#commit-message格式" class="headerlink" title="commit message格式"></a>commit message格式</h1><p>&lt;type&gt;(&lt;scope&gt;):&lt;subject&gt;  即：&lt;commit类型&gt;(影响范围)：具体描述</p>
<p>举例 fix(DOA):fixed invalid user table indexes.</p>
<p>type:指明git commit的类别， 应该使用下面的类型</p>
<blockquote>
<ul>
<li>【feat】:新增功能</li>
<li>【fix】:修复bug</li>
<li>【docs】:仅仅修改了文档， 比如README，CHANGELOG等等</li>
<li>【test】:增加&#x2F;修改测试用例，包括单元测试、集成测试等</li>
<li>【style】:修改了空行、缩进格式、引用包排序等等（不改变代码逻辑）</li>
<li>【perf】:优化相关内容，比如提升性能、体验、算法等</li>
<li>【refactor】:重构代码，没有新功能或者bug修复</li>
<li>【chore】:改变构建流程、或者增加依赖库、工具等</li>
<li>【revert】:回滚到上一个版本</li>
<li>【merge】:代码合并</li>
</ul>
</blockquote>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/git/" rel="tag">git</a></li></ul>

    </footer>
  </div>

   
   
  
</article>

    
    <article
  id="post-linux/linux chmod 用法"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2023/04/17/linux/linux-chmod-yong-fa/"
    >linux chmod用法</a> 
</h2>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/2023/04/17/linux/linux-chmod-yong-fa/" class="article-date">
  <time datetime="2023-04-17T02:15:31.000Z" itemprop="datePublished">2023-04-17</time>
</a> 
  <div class="article-category">
    <a class="article-category-link" href="/categories/linux/">linux</a>
  </div>
   
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <h1 id="1-查看文件夹权限"><a href="#1-查看文件夹权限" class="headerlink" title="1.查看文件夹权限"></a>1.查看文件夹权限</h1><p>通过命令ll 或者 ls -l 查看当前路径下各个文件或者文件夹权限，如下图所示：<br><img src="/images/linux1.jpg" alt="avatar"><br>其中开头固定10个字符，其字符意义表示如下：</p>
<blockquote>
<ul>
<li>第1个字符：表示该文件的类型，可以是d(目录)、b(块设备)、c(字符设备文件)、“-”(普通文件)、“l”(链接文件)等。</li>
<li>第2-4个字符：表示该文件的属主用户(user)对该文件的访问权限。</li>
<li>第5-7个字符：表示该文件的属组内各成员用户对该文件的访问权限。</li>
<li>第8-10个字符：表示其它任何用户(Other)对该文件的访问权限。</li>
</ul>
</blockquote>
<p>其中r+w+x &#x3D; 4+2+1, r权限表示可以读取文件的内容，w权限表示可以编辑或者修改文件，x(execute)权限表示可以执行文件（只有可执行文件才有x权限)，比如在当前文件夹下mkdir一个新的文件夹或者touch 一个新文件需要x执行权限。</p>
<h1 id="2-更改权限"><a href="#2-更改权限" class="headerlink" title="2.更改权限"></a>2.更改权限</h1><pre><code>chmod -R 777 uploads: 更改当前路径下的uploads文件夹权限。
补充：
ls -ll：查看当前路径下所有文件以及文件夹大小，展示的是字节数。
ls -lh：查看当前路径下所有文件以及文件夹大小，以KB、MB等为单位进行展示。
</code></pre>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/linux/" rel="tag">linux</a></li></ul>

    </footer>
  </div>

   
   
  
</article>

    
    <article
  id="post-git/git 上传本地仓库到远程仓库"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2023/04/13/git/git-shang-chuan-ben-di-cang-ku-dao-yuan-cheng-cang-ku/"
    >上传git仓库</a> 
</h2>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/2023/04/13/git/git-shang-chuan-ben-di-cang-ku-dao-yuan-cheng-cang-ku/" class="article-date">
  <time datetime="2023-04-13T03:05:31.000Z" itemprop="datePublished">2023-04-13</time>
</a> 
  <div class="article-category">
    <a class="article-category-link" href="/categories/git/">git</a>
  </div>
   
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <p>上传git仓库：<br>1.首先需要通过 $git init 初始化本地仓库，即需要cd 到需要上传仓库的目录下，使用当前目录作为Git仓库，也可以指定目录作为Git仓库 $git init reponame</p>
<p>2.在本地仓库中添加内容 git add （可以是文件也可以是文件夹）git add README.md  or git add .   </p>
<p>3.提交到本地仓库$git commit -m “提交说明”.                                   </p>
<p>4.完成上述步骤后，即完成了本地仓库的提交，我们需要将其Push到远程仓库。  </p>
<p>5.首先设置提交代码时的用户信息：</p>
<blockquote>
<ul>
<li>$ git config –global user.name “name”  </li>
<li>$ git config –global user.email “emai”</li>
</ul>
</blockquote>
<p>6.连接github与本地       </p>
<blockquote>
<ul>
<li>命令行输入：ssh-keygen　　</li>
<li>得到生成的密钥：cat  ~&#x2F;.ssh&#x2F;id_rsa.pub</li>
<li>将密钥在github中进行配置：打开github，在头像下边的settings里面找到SSH and GPG keys，新建SSH，随便取个名字，并将上面得到的密钥粘贴进去。</li>
<li>通过命令查看本地与github是否连接成功：ssh -T <a href="mailto:&#103;&#105;&#x74;&#64;&#103;&#105;&#x74;&#x68;&#x75;&#98;&#46;&#x63;&#x6f;&#109;">&#103;&#105;&#x74;&#64;&#103;&#105;&#x74;&#x68;&#x75;&#98;&#46;&#x63;&#x6f;&#109;</a></li>
</ul>
<p>　　　　　　</p>
</blockquote>
<p>7.将远程仓库链接</p>
<blockquote>
<p>git remote add origin <a target="_blank" rel="noopener" href="https://github.com/">https://github.com/</a>…..  </p>
</blockquote>
<p>8.创建分支 </p>
<blockquote>
<p>git branch -M main  </p>
</blockquote>
<p>9.将本地仓库push到远程仓库 </p>
<blockquote>
<p>git push origin main  </p>
</blockquote>
<p>当出现推送失败“hint”的时候，可以强制推送上去。例如，更改远程仓库的名字后，本地仓库的内容将无法推送上去，可以通过-f强制推送，如：git push origin main -f </p>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/git/" rel="tag">git</a></li></ul>

    </footer>
  </div>

   
   
  
</article>

    
  </article>
  

  
</section>
</div>

      <footer class="footer">
  <div class="outer">
    <ul>
      <li>
        Copyrights &copy;
        2015-2023
        <i class="ri-heart-fill heart_icon"></i> twlelev的博客
      </li>
    </ul>
    <ul>
      <li>
        
      </li>
    </ul>
    <ul>
      <li>
        
      </li>
    </ul>
    <ul>
      
    </ul>
    <ul>
      
    </ul>
    <ul>
      <li>
        <!-- cnzz统计 -->
        
      </li>
    </ul>
  </div>
</footer>    
    </main>
    <div class="float_btns">
      <div class="totop" id="totop">
  <i class="ri-arrow-up-line"></i>
</div>

<div class="todark" id="todark">
  <i class="ri-moon-line"></i>
</div>

    </div>
    <aside class="sidebar on">
      <button class="navbar-toggle"></button>
<nav class="navbar">
  
  <div class="logo">
    <a href="/"><img src="/images/ayer-side.svg" alt="twlelev的博客"></a>
  </div>
  
  <ul class="nav nav-main">
    
    <li class="nav-item">
      <a class="nav-item-link" href="/">主页</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/archives">归档</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/categories">分类</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/tags">标签</a>
    </li>
    
  </ul>
</nav>
<nav class="navbar navbar-bottom">
  <ul class="nav">
    <li class="nav-item">
      
      <a class="nav-item-link nav-item-search"  title="搜索">
        <i class="ri-search-line"></i>
      </a>
      
      
      <a class="nav-item-link" target="_blank" href="/atom.xml" title="RSS Feed">
        <i class="ri-rss-line"></i>
      </a>
      
    </li>
  </ul>
</nav>
<div class="search-form-wrap">
  <div class="local-search local-search-plugin">
  <input type="search" id="local-search-input" class="local-search-input" placeholder="Search...">
  <div id="local-search-result" class="local-search-result"></div>
</div>
</div>
    </aside>
    <div id="mask"></div>

<!-- #reward -->
<div id="reward">
  <span class="close"><i class="ri-close-line"></i></span>
  <p class="reward-p"><i class="ri-cup-line"></i>请我喝杯咖啡吧~</p>
  <div class="reward-box">
    
    <div class="reward-item">
      <img class="reward-img" src="/images/alipay.jpg">
      <span class="reward-type">支付宝</span>
    </div>
    
    
    <div class="reward-item">
      <img class="reward-img" src="/images/wechat.jpg">
      <span class="reward-type">微信</span>
    </div>
    
  </div>
</div>
    
<script src="/js/jquery-3.6.0.min.js"></script>
 
<script src="/js/lazyload.min.js"></script>

<!-- Tocbot -->

<script src="https://cdn.staticfile.org/jquery-modal/0.9.2/jquery.modal.min.js"></script>
<link
  rel="stylesheet"
  href="https://cdn.staticfile.org/jquery-modal/0.9.2/jquery.modal.min.css"
/>
<script src="https://cdn.staticfile.org/justifiedGallery/3.8.1/js/jquery.justifiedGallery.min.js"></script>

<script src="/dist/main.js"></script>

<!-- ImageViewer -->
 <!-- Root element of PhotoSwipe. Must have class pswp. -->
<div class="pswp" tabindex="-1" role="dialog" aria-hidden="true">

    <!-- Background of PhotoSwipe. 
         It's a separate element as animating opacity is faster than rgba(). -->
    <div class="pswp__bg"></div>

    <!-- Slides wrapper with overflow:hidden. -->
    <div class="pswp__scroll-wrap">

        <!-- Container that holds slides. 
            PhotoSwipe keeps only 3 of them in the DOM to save memory.
            Don't modify these 3 pswp__item elements, data is added later on. -->
        <div class="pswp__container">
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
        </div>

        <!-- Default (PhotoSwipeUI_Default) interface on top of sliding area. Can be changed. -->
        <div class="pswp__ui pswp__ui--hidden">

            <div class="pswp__top-bar">

                <!--  Controls are self-explanatory. Order can be changed. -->

                <div class="pswp__counter"></div>

                <button class="pswp__button pswp__button--close" title="Close (Esc)"></button>

                <button class="pswp__button pswp__button--share" style="display:none" title="Share"></button>

                <button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>

                <button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button>

                <!-- Preloader demo http://codepen.io/dimsemenov/pen/yyBWoR -->
                <!-- element will get class pswp__preloader--active when preloader is running -->
                <div class="pswp__preloader">
                    <div class="pswp__preloader__icn">
                        <div class="pswp__preloader__cut">
                            <div class="pswp__preloader__donut"></div>
                        </div>
                    </div>
                </div>
            </div>

            <div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap">
                <div class="pswp__share-tooltip"></div>
            </div>

            <button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)">
            </button>

            <button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)">
            </button>

            <div class="pswp__caption">
                <div class="pswp__caption__center"></div>
            </div>

        </div>

    </div>

</div>

<link rel="stylesheet" href="https://cdn.staticfile.org/photoswipe/4.1.3/photoswipe.min.css">
<link rel="stylesheet" href="https://cdn.staticfile.org/photoswipe/4.1.3/default-skin/default-skin.min.css">
<script src="https://cdn.staticfile.org/photoswipe/4.1.3/photoswipe.min.js"></script>
<script src="https://cdn.staticfile.org/photoswipe/4.1.3/photoswipe-ui-default.min.js"></script>

<script>
    function viewer_init() {
        let pswpElement = document.querySelectorAll('.pswp')[0];
        let $imgArr = document.querySelectorAll(('.article-entry img:not(.reward-img)'))

        $imgArr.forEach(($em, i) => {
            $em.onclick = () => {
                // slider展开状态
                // todo: 这样不好，后面改成状态
                if (document.querySelector('.left-col.show')) return
                let items = []
                $imgArr.forEach(($em2, i2) => {
                    let img = $em2.getAttribute('data-idx', i2)
                    let src = $em2.getAttribute('data-target') || $em2.getAttribute('src')
                    let title = $em2.getAttribute('alt')
                    // 获得原图尺寸
                    const image = new Image()
                    image.src = src
                    items.push({
                        src: src,
                        w: image.width || $em2.width,
                        h: image.height || $em2.height,
                        title: title
                    })
                })
                var gallery = new PhotoSwipe(pswpElement, PhotoSwipeUI_Default, items, {
                    index: parseInt(i)
                });
                gallery.init()
            }
        })
    }
    viewer_init()
</script> 
<!-- MathJax -->

<!-- Katex -->

<!-- busuanzi  -->

<!-- ClickLove -->

<!-- ClickBoom1 -->

<!-- ClickBoom2 -->

<!-- CodeCopy -->
 
<link rel="stylesheet" href="/css/clipboard.css">
 <script src="https://cdn.staticfile.org/clipboard.js/2.0.10/clipboard.min.js"></script>
<script>
  function wait(callback, seconds) {
    var timelag = null;
    timelag = window.setTimeout(callback, seconds);
  }
  !function (e, t, a) {
    var initCopyCode = function(){
      var copyHtml = '';
      copyHtml += '<button class="btn-copy" data-clipboard-snippet="">';
      copyHtml += '<i class="ri-file-copy-2-line"></i><span>COPY</span>';
      copyHtml += '</button>';
      $(".highlight .code pre").before(copyHtml);
      $(".article pre code").before(copyHtml);
      var clipboard = new ClipboardJS('.btn-copy', {
        target: function(trigger) {
          return trigger.nextElementSibling;
        }
      });
      clipboard.on('success', function(e) {
        let $btn = $(e.trigger);
        $btn.addClass('copied');
        let $icon = $($btn.find('i'));
        $icon.removeClass('ri-file-copy-2-line');
        $icon.addClass('ri-checkbox-circle-line');
        let $span = $($btn.find('span'));
        $span[0].innerText = 'COPIED';
        
        wait(function () { // 等待两秒钟后恢复
          $icon.removeClass('ri-checkbox-circle-line');
          $icon.addClass('ri-file-copy-2-line');
          $span[0].innerText = 'COPY';
        }, 2000);
      });
      clipboard.on('error', function(e) {
        e.clearSelection();
        let $btn = $(e.trigger);
        $btn.addClass('copy-failed');
        let $icon = $($btn.find('i'));
        $icon.removeClass('ri-file-copy-2-line');
        $icon.addClass('ri-time-line');
        let $span = $($btn.find('span'));
        $span[0].innerText = 'COPY FAILED';
        
        wait(function () { // 等待两秒钟后恢复
          $icon.removeClass('ri-time-line');
          $icon.addClass('ri-file-copy-2-line');
          $span[0].innerText = 'COPY';
        }, 2000);
      });
    }
    initCopyCode();
  }(window, document);
</script>
 
<!-- CanvasBackground -->

<script>
  if (window.mermaid) {
    mermaid.initialize({ theme: "forest" });
  }
</script>


    
    

  </div>
</body>

</html>