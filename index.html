<!DOCTYPE html>


<html lang="zh-CN">
  

    <head>
      <meta charset="utf-8" />
        
      <meta name="description" content="用于记录学习笔记的个人网站" />
      
      <meta
        name="viewport"
        content="width=device-width, initial-scale=1, maximum-scale=1"
      />
      <title> twlelev的博客</title>
  <meta name="generator" content="hexo-theme-ayer">
      
      <link rel="shortcut icon" href="/favicon.ico" />
       
<link rel="stylesheet" href="/dist/main.css">

      
<link rel="stylesheet" href="/css/fonts/remixicon.css">

      
<link rel="stylesheet" href="/css/custom.css">
 
      <script src="https://cdn.staticfile.org/pace/1.2.4/pace.min.js"></script>
       
 

      <link
        rel="stylesheet"
        href="https://cdn.jsdelivr.net/npm/@sweetalert2/theme-bulma@5.0.1/bulma.min.css"
      />
      <script src="https://cdn.jsdelivr.net/npm/sweetalert2@11.0.19/dist/sweetalert2.min.js"></script>

      <!-- mermaid -->
      
      <style>
        .swal2-styled.swal2-confirm {
          font-size: 1.6rem;
        }
      </style>
    <link rel="stylesheet" href="/css/prism-tomorrow.css" type="text/css">
<link rel="stylesheet" href="/css/prism-line-numbers.css" type="text/css"></head>
  </html>
</html>


<body>
  <div id="app">
    
      
    <main class="content on">
      
<section class="cover">
    
  <div class="cover-frame">
    <div class="bg-box">
      <img src="/images/cat.jpg" alt="image frame" />
    </div>
    <div class="cover-inner text-center text-white">
      <h1><a href="/">twlelev的博客</a></h1>
      <div id="subtitle-box">
        
        <span id="subtitle"></span>
        
      </div>
      <div>
        
      </div>
    </div>
  </div>
  <div class="cover-learn-more">
    <a href="javascript:void(0)" class="anchor"><i class="ri-arrow-down-line"></i></a>
  </div>
</section>



<script src="https://cdn.staticfile.org/typed.js/2.0.12/typed.min.js"></script>


<!-- Subtitle -->

  <script>
    try {
      var typed = new Typed("#subtitle", {
        strings: ['再努力一点', '不必在乎别人提前拥有', '愿你的努力都能得到回报'],
        startDelay: 0,
        typeSpeed: 200,
        loop: true,
        backSpeed: 100,
        showCursor: true
      });
    } catch (err) {
      console.log(err)
    }
  </script>
  
<div id="main">
  <section class="outer">
  
  
  

<div class="notice" style="margin-top:50px">
    <i class="ri-heart-fill"></i>
    <div class="notice-content" id="broad"></div>
</div>
<script type="text/javascript">
    fetch('https://v1.hitokoto.cn')
        .then(response => response.json())
        .then(data => {
            document.getElementById("broad").innerHTML = data.hitokoto;
        })
        .catch(console.error)
</script>

<style>
    .notice {
        padding: 20px;
        border: 1px dashed #e6e6e6;
        color: #969696;
        position: relative;
        display: inline-block;
        width: 100%;
        background: #fbfbfb50;
        border-radius: 10px;
    }

    .notice i {
        float: left;
        color: #999;
        font-size: 16px;
        padding-right: 10px;
        vertical-align: middle;
        margin-top: -2px;
    }

    .notice-content {
        display: initial;
        vertical-align: middle;
    }
</style>
  
  <article class="articles">
    
    
    
    
    <article
  id="post-AIGC/LCM-LORA"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2025/12/19/aigc/lcm-lora/"
    >LCM LORA</a> 
</h2>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/2025/12/19/aigc/lcm-lora/" class="article-date">
  <time datetime="2025-12-19T07:04:10.000Z" itemprop="datePublished">2025-12-19</time>
</a> 
  <div class="article-category">
    <a class="article-category-link" href="/categories/AIGC/">AIGC</a>
  </div>
   
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <h1 id="技术深度解析：LCM-LoRA-原理与-Scheduler-源码实现"><a href="#技术深度解析：LCM-LoRA-原理与-Scheduler-源码实现" class="headerlink" title="技术深度解析：LCM-LoRA 原理与 Scheduler 源码实现"></a>技术深度解析：LCM-LoRA 原理与 Scheduler 源码实现</h1><h2 id="1-背景介绍"><a href="#1-背景介绍" class="headerlink" title="1. 背景介绍"></a>1. 背景介绍</h2><p>在扩散模型（Diffusion Models）的推理过程中，传统的采样方法（如 DDIM, Euler）通常需要 20-50 步迭代。<strong>一致性模型（Consistency Models, CM）</strong> 的出现旨在打破这一限制，通过学习一个“一致性映射”，模型可以直接从噪声状态 $x_t$ 预测到 $x_0$。<br><strong>本质：</strong> 不是在求解 ODE，而是在直接预测 ODE 轨迹的<strong>不动点</strong>。</p>
<p><strong>LCM-LoRA</strong> 则是将 LCM 的蒸馏技术与 LoRA（低秩自适应）结合，使得原本庞大的采样步数可以压缩至 2-8 步，且可以像普通 LoRA 一样灵活插拔，极大地降低了推理成本。</p>
<hr>
<h2 id="2-核心数学理论"><a href="#2-核心数学理论" class="headerlink" title="2. 核心数学理论"></a>2. 核心数学理论</h2><h3 id="2-1-概率流-ODE-PF-ODE"><a href="#2-1-概率流-ODE-PF-ODE" class="headerlink" title="2.1 概率流 ODE (PF-ODE)"></a>2.1 概率流 ODE (PF-ODE)</h3><p>扩散模型的前向过程可以映射为一个概率流常微分方程（Probability Flow ODE）。传统的采样器本质上是在数值求解这个 ODE。</p>
<h3 id="2-2-一致性映射（Consistency-Mapping）"><a href="#2-2-一致性映射（Consistency-Mapping）" class="headerlink" title="2.2 一致性映射（Consistency Mapping）"></a>2.2 一致性映射（Consistency Mapping）</h3><p>一致性模型旨在学习一个函数 $f(x_t, t)$，其满足： $$f(x_t, t) &#x3D; f(x_{t’}, t’) &#x3D; x_0$$ 这意味着对于同一条 PF-ODE 轨迹上的任何点，无论时间步 $t$ 是多少，经过该函数映射后都应该指向同一个终点 $x_0$。</p>
<h3 id="2-3-LCM-蒸馏公式"><a href="#2-3-LCM-蒸馏公式" class="headerlink" title="2.3 LCM 蒸馏公式"></a>2.3 LCM 蒸馏公式</h3><p>LCM 在训练时使用预训练模型作为指导，通过以下边界条件定义映射： $$\hat{x}<em>0 &#x3D; f_\theta(x_t, t) &#x3D; c</em>{skip}(t)x_t + c_{out}(t)F_\theta(x_t, t)$$ 其中：</p>
<ul>
<li>$c_{skip}(t)$ 和 $c_{out}(t)$ 是缩放系数，确保在 $t&#x3D;0$ 时满足边界条件 $f(x_0, 0) &#x3D; x_0$。</li>
<li>$F_\theta(x_t, t)$ 是神经网络预测的内容（通常是基于噪声预测）。</li>
</ul>
<h2 id="3-Scheduler-源码深度分析"><a href="#3-Scheduler-源码深度分析" class="headerlink" title="3. Scheduler 源码深度分析"></a>3. Scheduler 源码深度分析</h2><p>结合 <code>diffusers</code> 库中的 <code>LCMScheduler</code>，我们可以看到理论是如何转化为代码的。</p>
<h3 id="核心步骤-1：预测并还原-x-0"><a href="#核心步骤-1：预测并还原-x-0" class="headerlink" title="核心步骤 1：预测并还原 $x_0$"></a>核心步骤 1：预测并还原 $x_0$</h3><p>这是所有去噪逻辑的起点。调度器根据 UNet 预测的噪声 $\epsilon_\theta$（即代码中的 model_output）反推 $x_0$：</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token comment" spellcheck="true"># 理论公式：x_0 = (x_t - sqrt(1 - alpha_t) * epsilon) / sqrt(alpha_t)</span>
pred_original_sample <span class="token operator">=</span> <span class="token punctuation">(</span>sample <span class="token operator">-</span> <span class="token punctuation">(</span><span class="token number">1</span> <span class="token operator">-</span> alpha_prod_t<span class="token punctuation">)</span><span class="token operator">**</span><span class="token number">0.5</span> <span class="token operator">*</span> model_output<span class="token punctuation">)</span> <span class="token operator">/</span> alpha_prod_t<span class="token operator">**</span><span class="token number">0.5</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<h3 id="核心步骤-2：应用一致性比例进行跳跃"><a href="#核心步骤-2：应用一致性比例进行跳跃" class="headerlink" title="核心步骤 2：应用一致性比例进行跳跃"></a>核心步骤 2：应用一致性比例进行跳跃</h3><p>传统调度器会根据导数走一小步，而 LCM 调度器通过 <code>c_skip</code> 和 <code>c_out</code> 执行“跨步”：</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token comment" spellcheck="true"># c_skip 和 c_out 由当前时间步 t 决定</span>
c_skip<span class="token punctuation">,</span> c_out <span class="token operator">=</span> self<span class="token punctuation">.</span>get_scalings_for_boundary_condition<span class="token punctuation">(</span>timestep<span class="token punctuation">)</span>

<span class="token comment" spellcheck="true"># 直接计算下一状态 (LCM 模型的一致性步进)</span>
<span class="token comment" spellcheck="true"># prev_sample = x_&amp;#123;t-1&amp;#125;</span>
prev_sample <span class="token operator">=</span> c_skip <span class="token operator">*</span> sample <span class="token operator">+</span> c_out <span class="token operator">*</span> pred_original_sample
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h3 id="核心步骤-3：多步随机性补偿"><a href="#核心步骤-3：多步随机性补偿" class="headerlink" title="核心步骤 3：多步随机性补偿"></a>核心步骤 3：多步随机性补偿</h3><p>为了增强生成的纹理细节，如果是运行多步（Multi-step LCM），会在最后注入微量的高斯噪声：</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">if</span> self<span class="token punctuation">.</span>num_inference_steps <span class="token operator">></span> <span class="token number">1</span> <span class="token operator">and</span> timestep <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">:</span>
    noise <span class="token operator">=</span> randn_tensor<span class="token punctuation">(</span>model_output<span class="token punctuation">.</span>shape<span class="token punctuation">,</span> generator<span class="token operator">=</span>generator<span class="token punctuation">)</span>
    prev_sample <span class="token operator">=</span> prev_sample <span class="token operator">+</span> noise <span class="token operator">*</span> self<span class="token punctuation">.</span>sigmas<span class="token punctuation">[</span>timestep<span class="token punctuation">]</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/AIGC/" rel="tag">AIGC</a></li></ul>

    </footer>
  </div>

   
   
  
</article>

    
    <article
  id="post-AIGC/DDIM"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2025/12/18/aigc/ddim/"
    >DDIM核心原理</a> 
</h2>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/2025/12/18/aigc/ddim/" class="article-date">
  <time datetime="2025-12-18T07:31:01.000Z" itemprop="datePublished">2025-12-18</time>
</a> 
  <div class="article-category">
    <a class="article-category-link" href="/categories/AIGC/">AIGC</a>
  </div>
   
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <h2 id="DDPM与DDIM区别"><a href="#DDPM与DDIM区别" class="headerlink" title="DDPM与DDIM区别"></a>DDPM与DDIM区别</h2><p> DDPM 假设反向过程是一个马尔可夫链，反向采样必须一步步迭代，$x_{t-1}$ 只依赖于前一步 $x_t$。</p>
<p>DDIM将扩散过程从马尔科夫链推广到非马尔科夫链。同样的训练模型，采样时可以从 1000 步跳到 50 步，速度提升 20 倍，且质量几乎不打折扣。</p>
<h2 id="DDIM原理"><a href="#DDIM原理" class="headerlink" title="DDIM原理"></a>DDIM原理</h2><p>DDIM 的核心观察是：__训练模型时，我们其实只关心每一个边缘分布 $q(x_t|x_0)$ 是否符合高斯分布，而不必关心它们之间是如何演化的。</p>
<h4 id="A-共享的边缘分布"><a href="#A-共享的边缘分布" class="headerlink" title="A. 共享的边缘分布"></a>A. 共享的边缘分布</h4><p>DDIM 重新设计了一个推理过程，它满足以下两个性质：</p>
<ol>
<li>__边缘分布一致__：对于任何 $t$，其 $q(x_t|x_0)$ 与 DDPM 完全相同（即 $\sqrt{\bar{\alpha}_t}x_0 + \sqrt{1-\bar{\alpha}_t}\epsilon$）。</li>
<li>_<em>非马尔可夫性__：$x_t$ 的生成可以依赖于 $x_0$ 和 $x</em>{t-1}$ 等更多信息。</li>
</ol>
<h4 id="B-核心公式推导"><a href="#B-核心公式推导" class="headerlink" title="B. 核心公式推导"></a>B. 核心公式推导</h4><p>DDIM 定义了一个新的条件分布 $q_\sigma(x_{t-1} | x_t, x_0)$： $$x_{t-1} &#x3D; \sqrt{\bar{\alpha}<em>{t-1}} \underbrace{\left( \frac{x_t - \sqrt{1-\bar{\alpha}<em>t} \epsilon_\theta(x_t)}{\sqrt{\bar{\alpha}<em>t}} \right)}</em>{\text{预测的 } x_0} + \underbrace{\sqrt{1-\bar{\alpha}</em>{t-1} - \sigma_t^2} \cdot \epsilon_\theta(x_t)}</em>{\text{指向 } x_t \text{ 的方向}} + \underbrace{\sigma_t \epsilon_t}_{\text{随机噪声}}$$</p>
<p>重新定义 $x_{t-1}$_<em>：DDIM 认为，$x</em>{prev}$（注意这里不是相邻的 $t-1$，而是子序列中的前一个步长）可以通过以下三部分的线性组合得到：</p>
<ul>
<li>__指向 $x_0$ 的分量__：由 $\hat{x}_0$ 确定。</li>
<li>__指向 $x_t$ 的方向分量__：利用 $\epsilon_\theta$ 确保它依然在当前的扩散路径上。</li>
<li>__随机噪声分量__：由 $\sigma$ 控制。</li>
</ul>
<p>在这个公式中，$\sigma_t$ 是一个可调参数：</p>
<ul>
<li>当 $\sigma_t^2 &#x3D; \frac{1-\bar{\alpha}_{t-1}}{1-\bar{\alpha}_t} \cdot \beta_t$ 时，__DDIM 退化回 DDPM__（马尔可夫随机采样）。</li>
<li>当 <strong>$\sigma_t &#x3D; 0$</strong> 时，过程变得完全确定 (Deterministic)__。此时的过程被称为 DDIM，它实际上是在解一个常微分方程 (ODE)。</li>
</ul>
<h4 id="C-为什么能跳步"><a href="#C-为什么能跳步" class="headerlink" title="C. 为什么能跳步?"></a>C. 为什么能跳步?</h4><p>DDIM 的公式定义的是 $x_{t-1}$ 如何由 $x_t$ 和 $x_0$ 组成，而这个 $t$ 和 $t-1$ __并不一定要是相邻的整数__。</p>
<h4 id="D-为什么训练好的-DDPM-模型可以直接用-DDIM"><a href="#D-为什么训练好的-DDPM-模型可以直接用-DDIM" class="headerlink" title="D. 为什么训练好的 DDPM 模型可以直接用 DDIM?"></a>D. 为什么训练好的 DDPM 模型可以直接用 DDIM?</h4><p>因为它们的优化目标（Loss Function）是完全一样的。</p>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/AIGC/" rel="tag">AIGC</a></li></ul>

    </footer>
  </div>

   
   
  
</article>

    
    <article
  id="post-AIGC"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2025/12/18/aigc/"
    >AIGC</a> 
</h2>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/2025/12/18/aigc/" class="article-date">
  <time datetime="2025-12-18T03:23:16.000Z" itemprop="datePublished">2025-12-18</time>
</a>    
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
   
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
    </footer>
  </div>

   
   
  
</article>

    
    <article
  id="post-AIGC/DDPM"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2025/12/18/aigc/ddpm/"
    >DDPM核心原理与简单工程实现</a> 
</h2>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/2025/12/18/aigc/ddpm/" class="article-date">
  <time datetime="2025-12-18T03:21:20.000Z" itemprop="datePublished">2025-12-18</time>
</a> 
  <div class="article-category">
    <a class="article-category-link" href="/categories/AIGC/">AIGC</a>
  </div>
   
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <h2 id="1-核心思想"><a href="#1-核心思想" class="headerlink" title="1.核心思想"></a>1.核心思想</h2><p>Diffusion 模型通过模拟分子的扩散过程，将图像逐步变成纯噪声（前向过程），然后学习一个神经网络来逆转这个过程，从噪声中还原图像（反向过程）。它本质上是一个马尔科夫链。</p>
<pre class="line-numbers language-Python"><code class="language-Python"># 前向过程：逐步加噪声
x_0 (原始图像) → x_1 → x_2 → ... → x_T (纯噪声)

# 反向过程：逐步去噪声  
x_T (纯噪声) → x_&#123;T-1&#125; → ... → x_1 → x_0 (生成图像)
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h2 id="2-前向过程-加噪声"><a href="#2-前向过程-加噪声" class="headerlink" title="2.前向过程(加噪声)"></a>2.前向过程(加噪声)</h2><p>给定初始数据$x_{0}$，每一步添加少量噪声<br>$q(x_t|x_{t-1}) &#x3D; N(x_t; √(1-β_t)·x_{t-1}, β_t·I)$</p>
<p>不需要一步步加噪，可以直接从 $x_0$ 得到 $x_t$：<br>$$q(x_t|x_0) &#x3D; N(x_t; √(ᾱ_t)·x_0, (1-ᾱ_t)·I)$$<br>$$x_t &#x3D; \sqrt{\bar{\alpha}_t} x_0 + \sqrt{1 - \bar{\alpha}_t} \epsilon, \quad \epsilon \sim \mathcal{N}(0, \mathbf{I})$$</p>
<p>其中$\beta_{t}$是<strong>噪声调度</strong>(noise schedule)，$ᾱ_t &#x3D; ∏(1-β_i)$是<strong>累积系数</strong></p>
<h2 id="3-反向过程-去噪声"><a href="#3-反向过程-去噪声" class="headerlink" title="3.反向过程(去噪声)"></a>3.反向过程(去噪声)</h2><p>目标是估计 $p(x_{t-1} | x_t)$。由于真实分布不可知，我们用神经网络 $\theta$ 来近似：<br>$p_θ(x_{t-1}|x_t) &#x3D; N(x_{t-1}; μ_θ(x_t, t), Σ_θ(x_t, t))$</p>
<p>反向过程为什么也可以用高斯分布建模：<br>贝叶斯定理：$q(x_{t-1}|x_t, x_0) ∝ q(x_t|x_{t-1}) * q(x_{t-1}|x_0)$<br>两个高斯的乘积仍然是高斯</p>
<h3 id="3-1-均值-mu-theta-的推导"><a href="#3-1-均值-mu-theta-的推导" class="headerlink" title="3.1 均值 $\mu_\theta$ 的推导"></a>3.1 均值 $\mu_\theta$ 的推导</h3><p>通过贝叶斯定理，在给定 $x_0$ 的条件下，后验分布 $q(x_{t-1}|x_t, x_0)$ 的均值 $\tilde{\mu}_t$ 为： $$\tilde{\mu}_t &#x3D; \frac{\sqrt{\alpha_t}(1-\bar{\alpha}*{t-1})}{1-\bar{\alpha}<em>t} x_t + \frac{\sqrt{\bar{\alpha}</em>{t-1}}\beta_t}{1-\bar{\alpha}_t} x_0$$ 代入 $x_0$ 的预测值后(由前向过程$x_0$与$x_t$和$\epsilon$，可以消掉$x_0$)，神经网络实际上只需要预测噪声 $\epsilon_\theta$： $$\mu_\theta(x_t, t) &#x3D; \frac{1}{\sqrt{\alpha_t}} \left( x_t - \frac{\beta_t}{\sqrt{1 - \bar{\alpha}_t}} \epsilon_\theta(x_t, t) \right)$$</p>
<h3 id="3-2-方差-Sigma-theta-的选择"><a href="#3-2-方差-Sigma-theta-的选择" class="headerlink" title="3.2 方差 $\Sigma_\theta$ 的选择"></a>3.2 方差 $\Sigma_\theta$ 的选择</h3><ul>
<li>__选择 1 (DDPM 原作)__：固定方差 $\sigma_t^2 &#x3D; \beta_t$ 或 $\sigma_t^2 &#x3D; \tilde{\beta}_t$。</li>
<li>__选择 2 (后验方差)__：$\tilde{\beta}<em>t &#x3D; \frac{1-\bar{\alpha}</em>{t-1}}{1-\bar{\alpha}_t} \cdot \beta_t$（训练更稳定）。</li>
<li>__选择 3 (可学习方差)__：在 Improved DDPM 中，模型也预测方差，以减少采样步数。</li>
</ul>
<p> <strong>均值 $μ_θ$ 和方差 $Σ_θ$的含义</strong><br>$μ_θ(x_t, t)$ - 预测的均值</p>
<ul>
<li>这是神经网络预测的”最可能”的 $x_{t-1}$</li>
<li>代表去噪后图像的中心估计<br>$Σ_θ(x_t, t)$ - 预测的方差</li>
<li>表示预测的不确定性</li>
<li>越大表示越不确定</li>
</ul>
<h2 id="4-训练与采样算法-Training-amp-Sampling"><a href="#4-训练与采样算法-Training-amp-Sampling" class="headerlink" title="4. 训练与采样算法 (Training &amp; Sampling)"></a>4. 训练与采样算法 (Training &amp; Sampling)</h2><h3 id="训练目标-简化"><a href="#训练目标-简化" class="headerlink" title="训练目标(简化)"></a>训练目标(简化)</h3><p>$L &#x3D; E_{t,x_0,ε}[||ε - ε_θ(x_t, t)||²]$<br>其中 $ε_θ$ 是神经网络预测的噪声</p>
<h3 id="采样步骤-Langevin-Dynamics"><a href="#采样步骤-Langevin-Dynamics" class="headerlink" title="采样步骤 (Langevin Dynamics)"></a>采样步骤 (Langevin Dynamics)</h3><ol>
<li>从 $x_T \sim \mathcal{N}(0, \mathbf{I})$ 开始。</li>
<li>循环 $t &#x3D; T, \dots, 1$：<ul>
<li>预测 $\epsilon_\theta$。</li>
<li>根据 $\mu_\theta$ 计算 $x_{t-1}$。</li>
<li>若 $t &gt; 1$，加入高斯噪声 $z \sim \mathcal{N}(0, \mathbf{I})$ 以维持随机性。</li>
</ul>
</li>
</ol>
<h2 id="5-DDPM简单工程实现"><a href="#5-DDPM简单工程实现" class="headerlink" title="5.DDPM简单工程实现"></a>5.DDPM简单工程实现</h2><pre class="line-numbers language-Python"><code class="language-Python">class DDPMSampler:
    def __init__(self, model, betas):
        self.model = model
        self.betas = betas
        self.alphas = 1 - betas
        self.alphas_bar = torch.cumprod(self.betas, dim=0)

    def sample(self, shape, num_steps=1000):

        """完整采样流程，展示所有重参数化的应用"""
        x_t = torch.randn(shape)
        for t in reversed(range(num_steps)):
            # ===== 1. 利用前向重参数化关系 =====
            # 为了训练网络预测噪声
            # x_t = √ᾱ_t * x_0 + √(1-ᾱ_t) * ε

            predicted_noise = self.model(x_t, t)

            # ===== 2. 均值参数化 =====
            # 将噪声预测转换为反向过程的分布均值
            # μ = 1/√α_t * (x_t - β_t/√(1-ᾱ_t) * ε_θ)

            alpha_t = self.alphas[t]
            alpha_bar_t = self.alphas_bar[t]
            beta_t = self.betas[t]
            mean = (1 / torch.sqrt(alpha_t)) * (
                x_t - (beta_t / torch.sqrt(1 - alpha_bar_t)) * predicted_noise
            )

            # 方差（DDPM论文中的固定选择）
            if t > 0:
                variance = beta_t  # 简化版
            else:
                variance = 0      
                
            # ===== 3. 采样重参数化 =====
            # 从 N(mean, variance) 采样
            if t > 0:
                noise = torch.randn_like(x_t)
                 x_t = mean + torch.sqrt(variance) * noise
            else:
                 x_t = mean
            return x_t


def train_diffusion_model(model, dataloader, num_epochs):
    """
    展示前向重参数化在训练中的作用
    """
    optimizer = torch.optim.Adam(model.parameters(), lr=1e-4)

    for epoch in range(num_epochs):
        for batch_idx, x_0 in enumerate(dataloader):
            # 清空梯度
            optimizer.zero_grad()
            # 随机采样时间步
            t = torch.randint(0, 1000, (x_0.shape[0],))
            epsilon = torch.randn_like(x_0)

            # 一步生成 x_t , x_t = √ᾱ_t * x_0 + √(1-ᾱ_t) * ε
            x_t = (
                sqrt_alpha_bar[t].view(-1, 1, 1, 1) * x_0 +
                sqrt_one_minus_alpha_bar[t].view(-1, 1, 1, 1) * epsilon
            )

            epsilon_pred = model(x_t, t)
            loss = F.mse_loss(epsilon_pred, epsilon)
            loss.backward()
            optimizer.step()
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/AIGC/" rel="tag">AIGC</a></li></ul>

    </footer>
  </div>

   
   
  
</article>

    
    <article
  id="post-git/git常用命令"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2025/12/18/git/git-chang-yong-ming-ling/"
    >git常用命令</a> 
</h2>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/2025/12/18/git/git-chang-yong-ming-ling/" class="article-date">
  <time datetime="2025-12-18T02:37:52.000Z" itemprop="datePublished">2025-12-18</time>
</a> 
  <div class="article-category">
    <a class="article-category-link" href="/categories/git/">git</a>
  </div>
   
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <h1 id="硬重置到远程分支"><a href="#硬重置到远程分支" class="headerlink" title="硬重置到远程分支"></a>硬重置到远程分支</h1><p>需要重新拉取远程分支，放弃本地更改。</p>
<pre><code>git fetch origin
git reset --hard origin/master
//master代表拉取重新拉取远程master分支
</code></pre>
<p><strong>git fetch 与git pull</strong><br>git fetch 仅下载远程更新，本地分支不修改<br>git pull 下载远程分支+自动合并，本地分支修改，自动合并到当前分支</p>
<pre><code>git fetch origin:
远程仓库 ──下载──&gt; 远程跟踪分支(origin/master)    本地分支(master)
                        ↓                              ↓
                   已更新                           未改变

git pull origin master:
远程仓库 ──下载──&gt; 远程跟踪分支(origin/master) ──合并──&gt; 本地分支(master)
                                                        ↓
                                                     已更新
</code></pre>
<h1 id="合并解决冲突"><a href="#合并解决冲突" class="headerlink" title="合并解决冲突"></a>合并解决冲突</h1><h2 id="git-pull冲突情况"><a href="#git-pull冲突情况" class="headerlink" title="git pull冲突情况"></a>git pull冲突情况</h2><p>当本地有未提交的修改(工作区有改动)，执行git pull时，git 会阻止pull操作</p>
<pre><code>error: Your local changes to the following files would be overwritten by merge:
        path/to/file.cs
Please commit your changes or stash them before you merge.
Aborting
</code></pre>
<p><strong>解决方案：使用stash暂存本地修改</strong></p>
<pre><code>git stash  # 暂存本地修改
git pull origin master  # 拉取远程更新
git pop    # 恢复本地修改
# 如果有冲突，手动解决
</code></pre>
<h2 id="git-push冲突情况"><a href="#git-push冲突情况" class="headerlink" title="git push冲突情况"></a>git push冲突情况</h2><p><strong>git push到远程分支出现冲突</strong></p>
<pre><code>git pull origin master
git add [文件]
git commit -m &quot;&quot;
git push origin master 
# 出现冲突
</code></pre>
<p><strong>首先运行git status查看工作区状态</strong><br><strong>情况一：本地没有未提交的修改</strong></p>
<pre><code>$ git status
On branch master
Your branch is ahead of &#39;origin/master&#39; by X commits.
nothing to commit, working tree clean
</code></pre>
<p>工作区是干净的(“nothing to commit,working tree clean”)，push失败通常是因为远程有新的提交。拉取分支更新与本地仓库合并后再git push</p>
<pre><code>git pull origin master
git push origin master
</code></pre>
<p><strong>情况二：本地有未提交的修改</strong></p>
<pre><code>$ git status
On branch master
Changes not staged for commit:
  modified:   some_file.cs
  
Untracked files:
  new_file.cs
</code></pre>
<p>如果本地不需要保留修改:</p>
<pre><code>git checkout -- .
git pull origin master
git push origin master
</code></pre>
<p>如果本地需要保留修改:</p>
<pre><code>git stash 
git pull origin master
git push origin master
git stash pop
</code></pre>
<h3 id="情况三-git-pull-出现合并冲突"><a href="#情况三-git-pull-出现合并冲突" class="headerlink" title="情况三:git pull 出现合并冲突"></a>情况三:git pull 出现合并冲突</h3><p>如果本地需要保留修改，git pull origin master可能出现合并冲突。这是因为本地修改和远程提交的修改有冲突，需要手动解决</p>
<pre><code>$ git pull origin master
Auto-merging some_file.cs
CONFLICT (content): Merge conflict in some_file.cs
Automatic merge failed; fix conflicts and then commit the result.
</code></pre>
<p><strong>解决冲突</strong></p>
<pre><code># 手动编辑冲突文件，解决 &lt;&lt;&lt;&lt;&lt;&lt;&lt; ======= &gt;&gt;&gt;&gt;&gt;&gt;&gt; 标记

# 解决后
git add [冲突文件]    # 标记冲突已经解决
git commit -m &quot;解决合并冲突&quot;
git push origin master
</code></pre>
<pre><code>git status 显示：

Unmerged paths:                    ← 冲突的已跟踪文件
    both modified: xxx.cs          → git checkout --theirs xxx.cs
    both modified: xxx.asset       → git checkout --theirs xxx.asset
    deleted by them: yyy.bytes     → git rm yyy.bytes 

Untracked files:                   ← 未跟踪的文件
    zzz.png                        → git clean -fd 或 rm zzz.png
    zzz.meta                       → git clean -fd 或 rm zzz.meta


# 1.接受所有冲突文件的远程版本
git checkout --theirs .
# 2. 删除所有 untracked 文件
git clean -fd
</code></pre>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/git/" rel="tag">git</a></li></ul>

    </footer>
  </div>

   
   
  
</article>

    
    <article
  id="post-LLM/大模型实战营"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
     
    <div class="article-meta">
      <a href="/2025/12/18/llm/da-mo-xing-shi-zhan-ying/" class="article-date">
  <time datetime="2025-12-18T02:22:36.013Z" itemprop="datePublished">2025-12-18</time>
</a>    
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <h1 id="LMDeploy的量化和部署"><a href="#LMDeploy的量化和部署" class="headerlink" title="LMDeploy的量化和部署"></a>LMDeploy的量化和部署</h1><h2 id="环境配置"><a href="#环境配置" class="headerlink" title="环境配置"></a>环境配置</h2><h2 id="2服务部署"><a href="#2服务部署" class="headerlink" title="2服务部署"></a>2服务部署</h2><h3 id="2-1模型转换"><a href="#2-1模型转换" class="headerlink" title="2.1模型转换"></a>2.1模型转换</h3><p>使用TurboMind推理模型需要先将模型转换为TurboMind的格式，目前支持在线转换和李离线转换两种形式。在线转换可以直接加载Huggingface模型，离线转换需要先保存模型再加载。<br>TurboMind是一款关于LLM推理的高效推理引擎，基于英伟达的FasterTransformer研发而成。它的主要供功能包括：LLaMa结构模型的支持，persistent batch推理模式和可扩展的KV缓存管理器。</p>
<h4 id="2-1-1"><a href="#2-1-1" class="headerlink" title="2.1.1"></a>2.1.1</h4><ul>
<li>(<strong>IBAction</strong>)predict:(<strong>id</strong>)sender {</li>
</ul>
<p>    &#x2F;&#x2F; load image</p>
<p>    UIImage* image &#x3D; [UIImage imageNamed:@”test.jpg”];</p>
<p>    &#x2F;&#x2F; get rgba pixels from image</p>
<p>    <strong>int</strong> w &#x3D; image.size.width;</p>
<p>    <strong>int</strong> h &#x3D; image.size.height;</p>
<p>    fprintf(stderr, “%d x %d\n”, w, h);</p>
<p>    <strong>unsigned</strong> <strong>char</strong>* rgba &#x3D; <strong>new</strong> <strong>unsigned</strong> <strong>char</strong>[w<em>h</em>4];</p>
<p>    {</p>
<p>        CGColorSpaceRef colorSpace &#x3D; CGImageGetColorSpace(image.CGImage);</p>
<p>        CGContextRef contextRef &#x3D; CGBitmapContextCreate(rgba, w, h, 8, w*4,</p>
<p>                                                        colorSpace,</p>
<p>                                                        kCGImageAlphaNoneSkipLast | kCGBitmapByteOrderDefault);</p>
<p>        CGContextDrawImage(contextRef, CGRectMake(0, 0, w, h), image.CGImage);</p>
<p>        CGContextRelease(contextRef);</p>
<p>    }</p>
<p>    NSString *paramPath &#x3D; [[NSBundle mainBundle] pathForResource:@”squeezenet_v1.1” ofType:@”param”];</p>
<p>    NSString *binPath &#x3D; [[NSBundle mainBundle] pathForResource:@”squeezenet_v1.1” ofType:@”bin”];</p>
<p>    &#x2F;&#x2F; init net</p>
<p>    ncnn::Net net;</p>
<p>    {</p>
<p>        <strong>int</strong> r0 &#x3D; net.load_param([paramPath UTF8String]);</p>
<p>        <strong>int</strong> r1 &#x3D; net.load_model([binPath UTF8String]);</p>
<p>        fprintf(stderr, “net load %d %d\n”, r0, r1);</p>
<p>    }</p>
<p>    std::vector<a href="std::string">std::string</a> labels;</p>
<p>    NSString *labelPath &#x3D; [[NSBundle mainBundle] pathForResource:@”synset_words” ofType:@”txt”];</p>
<p>    load_labels([labelPath UTF8String], labels);</p>
<p>    &#x2F;&#x2F; run forward</p>
<p>    ncnn::Mat <strong>out</strong>;</p>
<p>    {</p>
<p>        ncnn::Extractor ex &#x3D; net.create_extractor();</p>
<p>        ex.set_light_mode(<strong>true</strong>);</p>
<p>        ex.set_num_threads(2);</p>
<p>        ncnn::Mat <strong>in</strong> &#x3D; ncnn::Mat::from_pixels_resize(rgba, ncnn::Mat::PIXEL_RGBA2BGR, w, h, 227, 227);</p>
<p>        <strong>const</strong> <strong>float</strong> mean_vals[3] &#x3D; {104.f, 117.f, 123.f};</p>
<p>        <strong>in</strong>.substract_mean_normalize(mean_vals, 0);</p>
<p>        ex.input(“data”, <strong>in</strong>);</p>
<p>        ex.extract(“prob”, <strong>out</strong>);</p>
<p>    }</p>
<p>    &#x2F;&#x2F; get prob</p>
<p>    std::vector&lt;**float**&gt; cls_scores;</p>
<p>    {</p>
<p>        cls_scores.resize(<strong>out</strong>.c);</p>
<p>        <strong>for</strong> (<strong>int</strong> j&#x3D;0; j&lt;<strong>out</strong>.c; j++)</p>
<p>        {</p>
<p>            <strong>const</strong> <strong>float</strong>* prob &#x3D; <strong>out</strong>.data + <strong>out</strong>.cstep * j;</p>
<p>            cls_scores[j] &#x3D; prob[0];</p>
<p>        }</p>
<p>    }</p>
<p>    NSString *result &#x3D; print_topk(cls_scores, 3, labels);</p>
<p>    <strong>self</strong>.resultLabel.text &#x3D; result;</p>
<p>    &#x2F;&#x2F; clean</p>
<p>    <strong>delete</strong>[] rgba;</p>
<p>}</p>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
    </footer>
  </div>

   
   
  
</article>

    
    <article
  id="post-强化学习/PPO Trick"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2024/06/12/qiang-hua-xue-xi/ppo-trick/"
    >强化学习</a> 
</h2>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/2024/06/12/qiang-hua-xue-xi/ppo-trick/" class="article-date">
  <time datetime="2024-06-12T12:15:00.000Z" itemprop="datePublished">2024-06-12</time>
</a> 
  <div class="article-category">
    <a class="article-category-link" href="/categories/DRL/">DRL</a>
  </div>
   
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <h1 id="1-H-264"><a href="#1-H-264" class="headerlink" title="1.H.264"></a>1.H.264</h1><h2 id="A-ffmpeg入门"><a href="#A-ffmpeg入门" class="headerlink" title="A.ffmpeg入门"></a>A.ffmpeg入门</h2><h6 id="a-YUV文件格式"><a href="#a-YUV文件格式" class="headerlink" title="a.YUV文件格式"></a>a.YUV文件格式</h6><p>ffmpeg是一个开源免费跨平台的视频和音频流方案，它提供了录制、转换以及流化音视频的完整解决方案，其包含了非常先进的音频&#x2F;视频编解码库libavcodec.</p>
<p>YUV(Y’CbCr)是一种像素格式，见于视频编码与静态图像。与RGB格式不同，YUV分别由一个称为Y(相当于灰度)的“亮度”分量和两个称为U(蓝色投影)和V(红色投影)的“色度”分量表示。<br>若只有亮度分量而没有色度分量，即为黑白图片。</p>
<p>一般用Y, U, V三者的比率来表示不同格式。<br>YUV444表示三者比值是4:4:4,即一个数据点，Y, U, V的空间大小都是一样的。所有格式中Y比值都是4，占一个字节，表示没有减少采样，不同格式中，减少只是UV的采样值。</p>
<p>4:4:4 ：表示色度值（UV）没有减少采样，即Y, U, V各占一个字节，总共占3字节。</p>
<p>4:2:2 ：表示UV分量采样减半，比如第一个像素采样Y,U，第二个像素采样Y,V，依次类推，这样每个点招用两个字节。</p>
<p>4:2:0 ：这种采样并不意味着只有Y,Cb而没有Cr分量，而是U,V分量隔行才采样一次。<br>即[Y0,U0,V0],[Y1,U1,V1],[Y2,U2,V2],[Y3,U3,V3]<br>采样后变为[Y0,U0],[Y1],[Y2,V1],[Y3]<br>由4:4:4的一个像素3字节，变为平均1个像素1.5字节。</p>
<blockquote>
<p>ffmpeg库的接口都是c函数，在cpp文件里调用ffmpeg函数需要注意，因为c语言不支持函数重载，一个用C写成的库如果想被C&#x2F;C++同时可以使用，在头文件应该加上以下代码</p>
</blockquote>
<pre><code> #ifdef __cplusplus
  extern &quot;C&quot; &#123;
  #endif 
  ...
  #ifdef __cplusplus
  &#125;
  #endif
</code></pre>
<h2 id="B-指数哥伦布编码（Exp-Golomb）"><a href="#B-指数哥伦布编码（Exp-Golomb）" class="headerlink" title="B.指数哥伦布编码（Exp-Golomb）"></a>B.指数哥伦布编码（Exp-Golomb）</h2><h4 id="a-熵编码"><a href="#a-熵编码" class="headerlink" title="a.熵编码"></a>a.熵编码</h4><p>熵编码属于无损编码，熵编码包括的编码方法有：香农-范诺编码、霍夫曼编码、算术编码、指数哥伦布编码、CABAC等，这一类编码方法的宗旨就是找到一种编码，使得码字的平均长度达到熵极限。具体而言，采用的准则为：对出现概率较大的符号，取较短的码长，而对出现概率较小的符号取较大的码长。</p>
<ul>
<li>熵<br>在信息论中，称为信息熵，信息越是随机，它的熵值越高，待编码的图像像素信息、码流的各个句法元素值都属于信息。<br>信息熵，就是为了解决信息的量化度量问题，它描述了整个信源的平均信息量。信息熵在我们的熵编码中，表示信源无损编码后平均码长的下限，故熵编码就是为了使编码后码字的平均码长尽量达到熵极限。平均码长越接近熵，说明熵编码的压缩效率越高。</li>
<li>熵和熵编码<br>熵编码可以分为以下两类：<br>（1）变长编码：霍夫曼编码、指数哥伦布编码、CAVLC等<br>（2）算术编码：CABAC等算数编码<br>在H.264中应用的有：指数哥伦布编码、CAVLC、CABAC</li>
</ul>
<h4 id="b-指数哥伦布编码"><a href="#b-指数哥伦布编码" class="headerlink" title="b.指数哥伦布编码"></a>b.指数哥伦布编码</h4><p>指数哥伦布编码是一种较简单的编码方法，正常来说，它可以拓展至K阶，即K阶指数哥伦布编码。而在H.264中使用的是0阶指数哥伦布编码。<br><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/565209140">详细介绍</a><br>0阶指数哥伦布编码，编码过程如下图所示：<br><img src="/../images/coder-decoder/expgolomb.png" alt="avatar"><br>以待编码码号code_num&#x3D;3为例：<br>第一步：将code_num +1 ,即3+1&#x3D;4；<br>第二步：将4写成二进制的形式：100<br>第三步：计算100的比特个数为3，在100前面写（3-1）个0，得到编码码字00100</p>
<p>基于上述的0阶，我们可以轻松扩展至K阶：<br>第一步：将code_num+2k<br>第二步：将code_num +2k写为二进制的形式<br>第三步：计算二进制的比特个数M,并在前面加上M-1个0，得到编码码字。</p>
<h4 id="c-指数哥伦布解码"><a href="#c-指数哥伦布解码" class="headerlink" title="c.指数哥伦布解码"></a>c.指数哥伦布解码</h4><p>这一描述在h264协议的9.1节，h264中的描述子，代表了解码过程，下面以描述子为主线，依次介绍h264中的4个指数哥伦布编码描述子：ue(v)、se(v)、me(v)、te(v).</p>
<ul>
<li>ue(v)<br>   ue(v)代表了0阶指数哥伦布编码，通常被称为无符号指数哥伦布编码。如下图：<br>   <img src="/../images/coder-decoder/decoder.png" alt="avatar"><br>   可以发现，码字和code_num之间，有以下公式：<br>   codeNum &#x3D; 2leadingzerobits-1+read_bits(leadingZeroBits)<br>   其中leadingZeroBits为中间1前面0的个数，所以在解码的时候，如果遇到描述子ue(v),则可以先数0的个数，数到1为止，其中0的个数即为leadingZeroBits.而read_bits(leadingZeroBits)，则为从中间1开始往后数leadingZeroBits个比特位的十进制值，上面解码的计算图如下：<br>   <img src="/../images/coder-decoder/decoder1.png" alt="avatar"></li>
<li>se(v)<br>  se(v)也称为有符号指数哥伦布编码，因此它的输出有可能为负。 当描述子为se(v)时，它的输入为上述过程解析出来的codeNum,即如果遇到se(v)需要先调用ue(v)，得出codeNum的值，然后调用se(v)的解析过程，se(v)的输出即为语法元素的值。	<br>  <img src="/../images/coder-decoder/decoder2.png" alt="avatar"></li>
</ul>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/DRL/" rel="tag">DRL</a></li></ul>

    </footer>
  </div>

   
   
  
</article>

    
    <article
  id="post-muduo学习/muduo学习"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2023/08/12/muduo-xue-xi/muduo-xue-xi/"
    >muduo</a> 
</h2>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/2023/08/12/muduo-xue-xi/muduo-xue-xi/" class="article-date">
  <time datetime="2023-08-12T02:15:31.000Z" itemprop="datePublished">2023-08-12</time>
</a> 
  <div class="article-category">
    <a class="article-category-link" href="/categories/muduo/">muduo</a>
  </div>
   
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <h1 id="线程安全的对象生命期管理"><a href="#线程安全的对象生命期管理" class="headerlink" title="线程安全的对象生命期管理"></a>线程安全的对象生命期管理</h1><p>why?</p>
<ul>
<li>在即将析构一个对象时，从何而知此刻是否有其它线程在执行该对象的成员函数？</li>
<li>如何保证在执行成员函数期间，对象不会在另一个线程被析构？</li>
<li>在调用某个对象的成员函数之前，如何得知这个对象还活着？它的析构函数会不会碰巧执行到一半？</li>
</ul>
<p>以shared_ptr一劳永逸解决这些问题。</p>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/muduo/" rel="tag">muduo</a></li></ul>

    </footer>
  </div>

   
   
  
</article>

    
    <article
  id="post-视频编码/视频编码基础"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2023/07/17/shi-pin-bian-ma/shi-pin-bian-ma-ji-chu/"
    >视频编码基础</a> 
</h2>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/2023/07/17/shi-pin-bian-ma/shi-pin-bian-ma-ji-chu/" class="article-date">
  <time datetime="2023-07-17T12:15:00.000Z" itemprop="datePublished">2023-07-17</time>
</a> 
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E8%A7%86%E9%A2%91%E7%BC%96%E7%A0%81%E5%9F%BA%E7%A1%80/">视频编码基础</a>
  </div>
   
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <h1 id="1-H-264"><a href="#1-H-264" class="headerlink" title="1.H.264"></a>1.H.264</h1><p><a target="_blank" rel="noopener" href="https://jordicenzano.name/2014/08/31/the-source-code-of-a-minimal-h264-encoder-c/">简单项目实现</a></p>
<h2 id="A-ffmpeg入门"><a href="#A-ffmpeg入门" class="headerlink" title="A.ffmpeg入门"></a>A.ffmpeg入门</h2><h6 id="a-YUV文件格式"><a href="#a-YUV文件格式" class="headerlink" title="a.YUV文件格式"></a>a.YUV文件格式</h6><p>ffmpeg是一个开源免费跨平台的视频和音频流方案，它提供了录制、转换以及流化音视频的完整解决方案，其包含了非常先进的音频&#x2F;视频编解码库libavcodec.</p>
<p>YUV(Y’CbCr)是一种像素格式，见于视频编码与静态图像。与RGB格式不同，YUV分别由一个称为Y(相当于灰度)的“亮度”分量和两个称为U(蓝色投影)和V(红色投影)的“色度”分量表示。<br>若只有亮度分量而没有色度分量，即为黑白图片。</p>
<p>一般用Y, U, V三者的比率来表示不同格式。<br>YUV444表示三者比值是4:4:4,即一个数据点，Y, U, V的空间大小都是一样的。所有格式中Y比值都是4，占一个字节，表示没有减少采样，不同格式中，减少只是UV的采样值。</p>
<p>4:4:4 ：表示色度值（UV）没有减少采样，即Y, U, V各占一个字节，总共占3字节。</p>
<p>4:2:2 ：表示UV分量采样减半，比如第一个像素采样Y,U，第二个像素采样Y,V，依次类推，这样每个点招用两个字节。</p>
<p>4:2:0 ：这种采样并不意味着只有Y,Cb而没有Cr分量，而是U,V分量隔行才采样一次。<br>即[Y0,U0,V0],[Y1,U1,V1],[Y2,U2,V2],[Y3,U3,V3]<br>采样后变为[Y0,U0],[Y1],[Y2,V1],[Y3]<br>由4:4:4的一个像素3字节，变为平均1个像素1.5字节。</p>
<blockquote>
<p>ffmpeg库的接口都是c函数，在cpp文件里调用ffmpeg函数需要注意，因为c语言不支持函数重载，一个用C写成的库如果想被C&#x2F;C++同时可以使用，在头文件应该加上以下代码</p>
</blockquote>
<pre><code> #ifdef __cplusplus
  extern &quot;C&quot; &#123;
  #endif 
  ...
  #ifdef __cplusplus
  &#125;
  #endif
</code></pre>
<h2 id="B-指数哥伦布编码（Exp-Golomb）"><a href="#B-指数哥伦布编码（Exp-Golomb）" class="headerlink" title="B.指数哥伦布编码（Exp-Golomb）"></a>B.指数哥伦布编码（Exp-Golomb）</h2><h4 id="a-熵编码"><a href="#a-熵编码" class="headerlink" title="a.熵编码"></a>a.熵编码</h4><p>熵编码属于无损编码，熵编码包括的编码方法有：香农-范诺编码、霍夫曼编码、算术编码、指数哥伦布编码、CABAC等，这一类编码方法的宗旨就是找到一种编码，使得码字的平均长度达到熵极限。具体而言，采用的准则为：对出现概率较大的符号，取较短的码长，而对出现概率较小的符号取较大的码长。</p>
<ul>
<li>熵<br>在信息论中，称为信息熵，信息越是随机，它的熵值越高，待编码的图像像素信息、码流的各个句法元素值都属于信息。<br>信息熵，就是为了解决信息的量化度量问题，它描述了整个信源的平均信息量。信息熵在我们的熵编码中，表示信源无损编码后平均码长的下限，故熵编码就是为了使编码后码字的平均码长尽量达到熵极限。平均码长越接近熵，说明熵编码的压缩效率越高。</li>
<li>熵和熵编码<br>熵编码可以分为以下两类：<br>（1）变长编码：霍夫曼编码、指数哥伦布编码、CAVLC等<br>（2）算术编码：CABAC等算数编码<br>在H.264中应用的有：指数哥伦布编码、CAVLC、CABAC</li>
</ul>
<h4 id="b-指数哥伦布编码"><a href="#b-指数哥伦布编码" class="headerlink" title="b.指数哥伦布编码"></a>b.指数哥伦布编码</h4><p>指数哥伦布编码是一种较简单的编码方法，正常来说，它可以拓展至K阶，即K阶指数哥伦布编码。而在H.264中使用的是0阶指数哥伦布编码。<br><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/565209140">详细介绍</a><br>0阶指数哥伦布编码，编码过程如下图所示：<br><img src="/../images/coder-decoder/expgolomb.png" alt="avatar"><br>以待编码码号code_num&#x3D;3为例：<br>第一步：将code_num +1 ,即3+1&#x3D;4；<br>第二步：将4写成二进制的形式：100<br>第三步：计算100的比特个数为3，在100前面写（3-1）个0，得到编码码字00100</p>
<p>基于上述的0阶，我们可以轻松扩展至K阶：<br>第一步：将code_num+2k<br>第二步：将code_num +2k写为二进制的形式<br>第三步：计算二进制的比特个数M,并在前面加上M-1个0，得到编码码字。</p>
<h4 id="c-指数哥伦布解码"><a href="#c-指数哥伦布解码" class="headerlink" title="c.指数哥伦布解码"></a>c.指数哥伦布解码</h4><p>这一描述在h264协议的9.1节，h264中的描述子，代表了解码过程，下面以描述子为主线，依次介绍h264中的4个指数哥伦布编码描述子：ue(v)、se(v)、me(v)、te(v).</p>
<ul>
<li>ue(v)<br>   ue(v)代表了0阶指数哥伦布编码，通常被称为无符号指数哥伦布编码。如下图：<br>   <img src="/../images/coder-decoder/decoder.png" alt="avatar"><br>   可以发现，码字和code_num之间，有以下公式：<br>   codeNum &#x3D; 2leadingzerobits-1+read_bits(leadingZeroBits)<br>   其中leadingZeroBits为中间1前面0的个数，所以在解码的时候，如果遇到描述子ue(v),则可以先数0的个数，数到1为止，其中0的个数即为leadingZeroBits.而read_bits(leadingZeroBits)，则为从中间1开始往后数leadingZeroBits个比特位的十进制值，上面解码的计算图如下：<br>   <img src="/../images/coder-decoder/decoder1.png" alt="avatar"></li>
<li>se(v)<br>  se(v)也称为有符号指数哥伦布编码，因此它的输出有可能为负。 当描述子为se(v)时，它的输入为上述过程解析出来的codeNum,即如果遇到se(v)需要先调用ue(v)，得出codeNum的值，然后调用se(v)的解析过程，se(v)的输出即为语法元素的值。	<br>  <img src="/../images/coder-decoder/decoder2.png" alt="avatar"></li>
</ul>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E8%A7%86%E9%A2%91%E7%BC%96%E7%A0%81%E5%9F%BA%E7%A1%80/" rel="tag">视频编码基础</a></li></ul>

    </footer>
  </div>

   
   
  
</article>

    
    <article
  id="post-NCNN/ncnn"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2023/07/08/ncnn/ncnn/"
    >ncnn基础</a> 
</h2>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/2023/07/08/ncnn/ncnn/" class="article-date">
  <time datetime="2023-07-08T06:54:31.000Z" itemprop="datePublished">2023-07-08</time>
</a> 
  <div class="article-category">
    <a class="article-category-link" href="/categories/ncnn/">ncnn</a>
  </div>
   
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <h1 id="1-NCNN简介"><a href="#1-NCNN简介" class="headerlink" title="1.NCNN简介"></a>1.NCNN简介</h1><p>ncnn是一个为手机端极致优化的高性能神经网络前向计算框架。ncnn从设计之初深刻考虑手机端的部署和应用。无第三方依赖，跨平台，手机端cpu的速度快于快于目前所有已知的开源框架。基于ncnn，开发者能够将深度学习算法轻松移植到手机端高效执行，开发出人工智能APP。</p>
<h1 id="2-怎么使用？"><a href="#2-怎么使用？" class="headerlink" title="2.怎么使用？"></a>2.怎么使用？</h1><ul>
<li>git clone ncnn仓库(若需要gpu推理需要submodule)</li>
</ul>
<pre><code>git clone https://github.com/Tencent/ncnn.git
cd ncnn
git submodule update --init
</code></pre>
<ul>
<li>(option) 下载vulkan_sdk(gpu推理配置)</li>
</ul>
<pre><code>wget https://sdk.lunarg.com/sdk/download/1.2.189.0/linux/vulkansdk-linux-x86_64-1.2.189.0.tar.gz?Human=true -O vulkansdk-linux-x86_64-1.2.189.0.tar.gz
tar -xf vulkansdk-linux-x86_64-1.2.189.0.tar.gz
export VULKAN_SDK=$(pwd)/1.2.189.0/x86_64
</code></pre>
<ul>
<li>编译ncnn库</li>
</ul>
<pre><code>## gpu推理
cd ncnn
mkdir -p build
cd build
cmake -DCMAKE_BUILD_TYPE=Release -DCMAKE_TOOLCHAIN_FILE=../toolchains/jetson.toolchain.cmake -DNCNN_VULKAN=ON -DNCNN_BUILD_EXAMPLES=ON ..
make -j$(nproc)

## 若不需要gpu推理
cd ncnn
mkdir build
cd build
cmake .. &amp;&amp; make -j4
make install #可以生成头文件和链接库
</code></pre>
<ul>
<li>onnx转ncnn<br>在编译好的build的情况下，.&#x2F;build&#x2F;tools&#x2F;onnx里面的脚本文件onnx2ncnn即为转ncnn推理模型的脚本，将model.onnx转为model.param和model.bin.</li>
</ul>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/ncnn/" rel="tag">ncnn</a></li></ul>

    </footer>
  </div>

   
   
  
</article>

    
    <article
  id="post-c++/c++ 基础"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2023/04/27/c/c-ji-chu/"
    >c++基础</a> 
</h2>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/2023/04/27/c/c-ji-chu/" class="article-date">
  <time datetime="2023-04-27T02:15:31.000Z" itemprop="datePublished">2023-04-27</time>
</a> 
  <div class="article-category">
    <a class="article-category-link" href="/categories/c/">c++</a>
  </div>
   
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <h1 id="1-static-inline"><a href="#1-static-inline" class="headerlink" title="1.static inline"></a>1.static inline</h1><p>对于普通函数而言，在a.h中声明然后在a.cpp中定义，再经过编译链接后我们在test1.cpp、test2.cpp中就可以通过#include”a.h”来调用函数。但是对于内联函数而言，我们无法在test1.cpp、test2.cpp中同时通过#include”a.h”来调用内联函数，也就是说一个.h中的内联函数被两个不同的文件包含，则会出现重名，链接失效。但如果使用static inline可以解决<br>这个问题，使用static修饰符，函数仅在文件内部可见。可以理解为一个inline在不同的.C里面生成了不同的实例，而且名字是完全相同的。</p>
<h1 id="2-static"><a href="#2-static" class="headerlink" title="2.static"></a>2.static</h1><p><strong>static可以修饰哪些变量:</strong></p>
<p>全局静态变量、局部静态变量、函数，除此之外，还可以修饰类中的静态成员变量以及静态成员函数。<br>&#96;&#96;</p>
<blockquote>
<ul>
<li>全局静态变量和局部静态变量都存储在静态存储区。存储在静态存储区的变量在编译期完成初始化，static定义的局部变量也是在编译时期分配的，而且生存期是永久的，直到生存期结束。</li>
<li>静态成员函数不能访问普通成员变量，静态函数在编译期完成了初始化，而此时类还未初始化，此时访问了不存在的变量。</li>
<li>全局静态变量相对于全局变量而言，全局变量具有外部链接性，通过声明extern关键字可以进行变量的赋值。而全局静态变量不具有外部链接性。</li>
<li>类中对象之间的成员变量是相互独立的 ，想要共用数据需要使用静态成员或者静态方法。由前面所知，在类中定义的静态成员函数以及静态成员变量在编译期完成初始化，因此，即使不定义对象，静态成员变量存储在静态存储区，其已经分配了内存空间，其不随对象的创建而创建，也不随对象的消亡而消亡。</li>
<li>静态成员函数只能访问静态成员变量。</li>
</ul>
</blockquote>
<p><strong>举个static相关例子如下</strong>：</p>
<pre><code>class StaticA
&#123;
public:
    StaticA()&#123;&#125;;
    ~ StaticA()&#123;&#125;;
    static int a; //静态成员变量只能在类外初始化
    static int teststatic()
    &#123;
        std::cout&lt;&lt;&quot;a:&quot;&lt;&lt;a&lt;&lt;std::endl;
    &#125;
&#125;;
int StaticA::a=1;

int main()
&#123;
StaticA *A=nullptr;
A-&gt;teststatic(); // 输出 a:1
return 0;
&#125;
</code></pre>
<h1 id="3-vitual虚函数"><a href="#3-vitual虚函数" class="headerlink" title="3.vitual虚函数"></a>3.vitual虚函数</h1><h2 id="构造函数、析构函数之虚函数"><a href="#构造函数、析构函数之虚函数" class="headerlink" title="构造函数、析构函数之虚函数"></a>构造函数、析构函数之虚函数</h2><p><strong>构造函数不可以是虚函数，而析构函数常常是虚函数。</strong><br>构造函数不可以是虚函数，原因如下：</p>
<blockquote>
<p>虚函数的调用是通过虚函数表来调用的。而虚函数表是由实例化的vptr指针来指向的，该实例化指针存放在对象的内部空间中且占8字节，需要调用构造函数完成初始化。因此，虚函数的调用需要发生在构造函数之后。</p>
</blockquote>
<p>析构函数可以常常是虚函数，原因如下：</p>
<blockquote>
<p>在实现多态性时，通过基类去指向派生类对象，只有申明为虚函数才能实现。如果定义的派生类对象是基类类型时，若没有声明基类虚析构函数，派生类在调用析构函数时，则会调用基类的虚构函数，会存在内存泄漏的风险。</p>
</blockquote>
<h2 id="类成员函数之虚函数"><a href="#类成员函数之虚函数" class="headerlink" title="类成员函数之虚函数"></a>类成员函数之虚函数</h2><p>派生类需要重写基类中的同名函数，则需要在基类中声明virtual虚函数，否则是不允许的。</p>
<h3 id="补充：重载与重写区别："><a href="#补充：重载与重写区别：" class="headerlink" title="补充：重载与重写区别："></a>补充：重载与重写区别：</h3><p>C++中的重载（Overloading）和重写（Overriding）是两个不同的概念，它们之间有以下几个不同点：</p>
<blockquote>
<ul>
<li><strong>定义位置不同</strong>:<br>重载是在同一个类中定义多个具有相同名称但参数列表不同的函数，重载函数可以包括不同类型、不同数量、不同顺序的参数。而重写是在派生类中重新定义一个从基类中继承的已有函数，函数名称、参数列表和返回值类型在基类和派生类中必须完全相同。</li>
<li><strong>对象的处理不同</strong>:<br>重载函数是编译期多态，由编译器根据传入的参数类型和数量来决定调用哪个函数。而重写函数是运行期多态，由运行时的实际对象类型来决定调用哪个函数。</li>
<li><strong>可访问性不同</strong>:<br>如果一个成员函数用<code>virtual</code>关键字声明为虚函数，则它可以在派生类中被重写。如果在派生类中重写基类中非虚函数的函数，这是不允许的。由于访问非虚函数是通过编译时分辨多态来实现的，所以在编译时通过基类指针或引用调用派生类的函数会调用基类函数，而不会调用派生类中的同名函数。</li>
<li><strong>参数匹配和返回值类型</strong>:<br>重载函数和重写函数的参数匹配和返回值类型在调用时有着不同的表现。在重载函数中，函数调用的正确匹配由编译器通过参数类型和数量决定。在重写函数中，参数列表和返回值类型必须与基类中的函数完全匹配，否则会导致编译错误。</li>
</ul>
</blockquote>
<h1 id="4-RAII"><a href="#4-RAII" class="headerlink" title="4.RAII"></a>4.RAII</h1><p>RAII是C++中一种非常重要的编程思想，全称为Resource Acquisition Is Initialization，中文为“资源获取即初始化”。它主要是利用C++的构造函数在对象初始化时自动获取资源，并在对象析构时自动释放资源的特性进行对象封装，以方便管理和避免资源泄露。</p>
<pre><code>class MemoryBlock
&#123;
public:
MemoryBlock():_length(0),_data(nullptr)&#123;&#125;

MemoryBlock(size_t length):_length(length),_data(new char[length])
&#123;
    std::cout &lt;&lt; &quot;constructed!&quot; &lt;&lt;std::endl;
&#125;

~MemoryBlock()
&#123;
    delete[] _data ;
    std::cout &lt;&lt; &quot;destructed!&quot; &lt;&lt; std::endl;
&#125;

// 拷贝构造函数，实现深度拷贝
MemoryBlock(const MemoryBlock&amp; other):_length(other._length),_data(new char[other._length])
&#123;
    std::copy(other._data, other._data+_length, _data);
    std::cout&lt;&lt; &quot;deep copy constructed!&quot; &lt;&lt;std::endl;
&#125;

// 赋值运算符实现深度赋值
MemoryBlock&amp; operator=(const MemoryBlock&amp; other)
&#123;
    if(this != &amp;other)
    &#123;
        if(_data!= nullptr) delete[] _data;
        _length = other._length;
        _data = new char[_length];
        std::copy(other._data, other._data+_length, _data);
    &#125;
    return *this;
&#125;

size_t length()
&#123;
return _length;
&#125;

char* data()
&#123;
return _data;
&#125;

private:
size_t _length;
char *_data;
&#125;;

int main()
&#123;

    MemoryBlock memoryblock1(20);
    
    std::strcpy(memoryblock1.data(), &quot;Hello World!&quot;);
    
    std::cout &lt;&lt; &quot;memoryblock1: &quot; &lt;&lt; memoryblock1.data() &lt;&lt; std::endl;
        
    // 拷贝构造函数生成类对象
    
    MemoryBlock memoryblock2(memoryblock1);
    
    std::cout &lt;&lt; &quot;memoryblock2: &quot; &lt;&lt; memoryblock2.data() &lt;&lt; std::endl;
    
    // 赋值生成对象
    MemoryBlock memoryblock3;
    memoryblock3 = memoryblock1;
    std::cout &lt;&lt; &quot;memoryblock3: &quot; &lt;&lt; memoryblock3.data() &lt;&lt; std::endl;
&#125;
</code></pre>
<h1 id="5-override"><a href="#5-override" class="headerlink" title="5.override"></a>5.override</h1><p><code>override</code>是一个关键字，用于指示派生类中的虚函数将覆盖基类中的虚函数。它可以用于明确地指示编译器该函数是用于覆盖基类中的虚函数，如果不匹配则会导致编译错误。<br><strong>作用</strong>：<br>在于提高程序的可读性以及健壮性，在派生类中重写基类函数需要声明基类函数为虚函数，声明关键字<code>override</code> 可以告诉读者重写了基类中的虚函数。<br>就程序运行而言，<code>override</code>声明与否不会对程序运行有任何影响。</p>
<h1 id="6-堆与栈"><a href="#6-堆与栈" class="headerlink" title="6.堆与栈"></a>6.堆与栈</h1><p>栈区内存由操作系统自动分配和释放，堆区内存由程序员手动分配和释放。<br>两者的主要区别：</p>
<ul>
<li>内存管理方式：栈区内存由操作系统自动分配和释放，而堆区内存则是手动分配和释放。</li>
<li>内存大小：栈区内存一般较小，通常为MB级别，而堆区内存相对较大，可以达到GB级别。</li>
<li>内存访问方式：栈区内存访问速度很快，因为它的内存分配方式是连续的，可以直接通过指针访问。堆区内存的访问速度较慢，因为它的内存分配方式是不连续的，需要通过指针间接访问。</li>
<li>内存分配效率：栈区内存的分配效率很高，因为它的内存分配方式是栈式的，只需移动指针即可。堆区的内存分配效率较低，它需要维护一张内存空闲表来记录哪些内存块已经分配，哪些内存块未被分配。</li>
<li>内存分配方式：栈区内存的分配方式是先进后出，堆区的内存分配方式是按照程序员的指令随时分配和释放，没有顺序限制。</li>
</ul>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/c/" rel="tag">c++</a></li></ul>

    </footer>
  </div>

   
   
  
</article>

    
    <article
  id="post-cuda/CUDA 编程简介"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2023/04/26/cuda/cuda-bian-cheng-jian-jie/"
    >cuda编程 简介</a> 
</h2>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/2023/04/26/cuda/cuda-bian-cheng-jian-jie/" class="article-date">
  <time datetime="2023-04-25T16:00:00.000Z" itemprop="datePublished">2023-04-26</time>
</a> 
  <div class="article-category">
    <a class="article-category-link" href="/categories/cuda/">cuda</a>
  </div>
   
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <h1 id="CUDA编程模型"><a href="#CUDA编程模型" class="headerlink" title="CUDA编程模型"></a>CUDA编程模型</h1><p>CUDA编程模型假设系统是由一个主机(CPU)和一个设备(GPU)组成的，而各自拥有独立的内存。因此，在CUDA编程中我们需要编写在设备(GPU)上运行的代码，也被称为核函数(Kernel)，其并行地运行在GPU的多个处理器上，这极大的提高了计算速度。</p>
<p>典型的CUDA程序执行步骤：</p>
<blockquote>
<ul>
<li>把数据从CPU内存拷贝到GPU内存。</li>
<li>调用核函数对存储在GPU内存中的数据进行操作。</li>
<li>将数据从GPU内存传回CPU内存。</li>
</ul>
</blockquote>
<p>CUDA编程模型的两个特点：<br>1.通过层次结构来组织线程</p>
<blockquote>
<ul>
<li>一般CPU一个核只支持一到两个硬件线程，而GPU在硬件层面就支持成百上千个并发线程。在CUDA编程中，线程是通过线程网格(Grid)、线程块(Block)、线程束(Warp)、线程(Thread)这几个层次管理。</li>
<li>由一个内核启动所产生的所有线程统称为一个网格(Grid),同一网格中的所有线程共享相同的全局内存空间。向下一级，一个网格由多个线程块(Block)构成。再下一级，一个线程块由一组线程(Thread)构成</li>
</ul>
</blockquote>
<p> 2.内存的使用</p>
<blockquote>
<ul>
<li>GPU中的各级缓存以及各种内存是可以软件控制的，这些内存包括寄存器、共享内存、常量内存、全局内存等。</li>
</ul>
</blockquote>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/cuda/" rel="tag">cuda</a></li></ul>

    </footer>
  </div>

   
   
  
</article>

    
  </article>
  

  
  <nav class="page-nav">
    
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="extend next" rel="next" href="/page/2/">下一页</a>
  </nav>
  
</section>
</div>

      <footer class="footer">
  <div class="outer">
    <ul>
      <li>
        Copyrights &copy;
        2015-2025
        <i class="ri-heart-fill heart_icon"></i> twlelev的博客
      </li>
    </ul>
    <ul>
      <li>
        
      </li>
    </ul>
    <ul>
      <li>
        
      </li>
    </ul>
    <ul>
      
    </ul>
    <ul>
      
    </ul>
    <ul>
      <li>
        <!-- cnzz统计 -->
        
      </li>
    </ul>
  </div>
</footer>    
    </main>
    <div class="float_btns">
      <div class="totop" id="totop">
  <i class="ri-arrow-up-line"></i>
</div>

<div class="todark" id="todark">
  <i class="ri-moon-line"></i>
</div>

    </div>
    <aside class="sidebar on">
      <button class="navbar-toggle"></button>
<nav class="navbar">
  
  <div class="logo">
    <a href="/"><img src="/images/ayer-side.svg" alt="twlelev的博客"></a>
  </div>
  
  <ul class="nav nav-main">
    
    <li class="nav-item">
      <a class="nav-item-link" href="/">主页</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/archives">归档</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/categories">分类</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/tags">标签</a>
    </li>
    
  </ul>
</nav>
<nav class="navbar navbar-bottom">
  <ul class="nav">
    <li class="nav-item">
      
      <a class="nav-item-link nav-item-search"  title="搜索">
        <i class="ri-search-line"></i>
      </a>
      
      
      <a class="nav-item-link" target="_blank" href="/atom.xml" title="RSS Feed">
        <i class="ri-rss-line"></i>
      </a>
      
    </li>
  </ul>
</nav>
<div class="search-form-wrap">
  <div class="local-search local-search-plugin">
  <input type="search" id="local-search-input" class="local-search-input" placeholder="Search...">
  <div id="local-search-result" class="local-search-result"></div>
</div>
</div>
    </aside>
    <div id="mask"></div>

<!-- #reward -->
<div id="reward">
  <span class="close"><i class="ri-close-line"></i></span>
  <p class="reward-p"><i class="ri-cup-line"></i>请我喝杯咖啡吧~</p>
  <div class="reward-box">
    
    <div class="reward-item">
      <img class="reward-img" src="/images/alipay.jpg">
      <span class="reward-type">支付宝</span>
    </div>
    
    
    <div class="reward-item">
      <img class="reward-img" src="/images/wechat.jpg">
      <span class="reward-type">微信</span>
    </div>
    
  </div>
</div>
    
<script src="/js/jquery-3.6.0.min.js"></script>
 
<script src="/js/lazyload.min.js"></script>

<!-- Tocbot -->

<script src="https://cdn.staticfile.org/jquery-modal/0.9.2/jquery.modal.min.js"></script>
<link
  rel="stylesheet"
  href="https://cdn.staticfile.org/jquery-modal/0.9.2/jquery.modal.min.css"
/>
<script src="https://cdn.staticfile.org/justifiedGallery/3.8.1/js/jquery.justifiedGallery.min.js"></script>

<script src="/dist/main.js"></script>

<!-- ImageViewer -->
 <!-- Root element of PhotoSwipe. Must have class pswp. -->
<div class="pswp" tabindex="-1" role="dialog" aria-hidden="true">

    <!-- Background of PhotoSwipe. 
         It's a separate element as animating opacity is faster than rgba(). -->
    <div class="pswp__bg"></div>

    <!-- Slides wrapper with overflow:hidden. -->
    <div class="pswp__scroll-wrap">

        <!-- Container that holds slides. 
            PhotoSwipe keeps only 3 of them in the DOM to save memory.
            Don't modify these 3 pswp__item elements, data is added later on. -->
        <div class="pswp__container">
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
        </div>

        <!-- Default (PhotoSwipeUI_Default) interface on top of sliding area. Can be changed. -->
        <div class="pswp__ui pswp__ui--hidden">

            <div class="pswp__top-bar">

                <!--  Controls are self-explanatory. Order can be changed. -->

                <div class="pswp__counter"></div>

                <button class="pswp__button pswp__button--close" title="Close (Esc)"></button>

                <button class="pswp__button pswp__button--share" style="display:none" title="Share"></button>

                <button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>

                <button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button>

                <!-- Preloader demo http://codepen.io/dimsemenov/pen/yyBWoR -->
                <!-- element will get class pswp__preloader--active when preloader is running -->
                <div class="pswp__preloader">
                    <div class="pswp__preloader__icn">
                        <div class="pswp__preloader__cut">
                            <div class="pswp__preloader__donut"></div>
                        </div>
                    </div>
                </div>
            </div>

            <div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap">
                <div class="pswp__share-tooltip"></div>
            </div>

            <button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)">
            </button>

            <button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)">
            </button>

            <div class="pswp__caption">
                <div class="pswp__caption__center"></div>
            </div>

        </div>

    </div>

</div>

<link rel="stylesheet" href="https://cdn.staticfile.org/photoswipe/4.1.3/photoswipe.min.css">
<link rel="stylesheet" href="https://cdn.staticfile.org/photoswipe/4.1.3/default-skin/default-skin.min.css">
<script src="https://cdn.staticfile.org/photoswipe/4.1.3/photoswipe.min.js"></script>
<script src="https://cdn.staticfile.org/photoswipe/4.1.3/photoswipe-ui-default.min.js"></script>

<script>
    function viewer_init() {
        let pswpElement = document.querySelectorAll('.pswp')[0];
        let $imgArr = document.querySelectorAll(('.article-entry img:not(.reward-img)'))

        $imgArr.forEach(($em, i) => {
            $em.onclick = () => {
                // slider展开状态
                // todo: 这样不好，后面改成状态
                if (document.querySelector('.left-col.show')) return
                let items = []
                $imgArr.forEach(($em2, i2) => {
                    let img = $em2.getAttribute('data-idx', i2)
                    let src = $em2.getAttribute('data-target') || $em2.getAttribute('src')
                    let title = $em2.getAttribute('alt')
                    // 获得原图尺寸
                    const image = new Image()
                    image.src = src
                    items.push({
                        src: src,
                        w: image.width || $em2.width,
                        h: image.height || $em2.height,
                        title: title
                    })
                })
                var gallery = new PhotoSwipe(pswpElement, PhotoSwipeUI_Default, items, {
                    index: parseInt(i)
                });
                gallery.init()
            }
        })
    }
    viewer_init()
</script> 
<!-- MathJax -->

<!-- Katex -->

<!-- busuanzi  -->

<!-- ClickLove -->

<!-- ClickBoom1 -->

<!-- ClickBoom2 -->

<!-- CodeCopy -->
 
<link rel="stylesheet" href="/css/clipboard.css">
 <script src="https://cdn.staticfile.org/clipboard.js/2.0.10/clipboard.min.js"></script>
<script>
  function wait(callback, seconds) {
    var timelag = null;
    timelag = window.setTimeout(callback, seconds);
  }
  !function (e, t, a) {
    var initCopyCode = function(){
      var copyHtml = '';
      copyHtml += '<button class="btn-copy" data-clipboard-snippet="">';
      copyHtml += '<i class="ri-file-copy-2-line"></i><span>COPY</span>';
      copyHtml += '</button>';
      $(".highlight .code pre").before(copyHtml);
      $(".article pre code").before(copyHtml);
      var clipboard = new ClipboardJS('.btn-copy', {
        target: function(trigger) {
          return trigger.nextElementSibling;
        }
      });
      clipboard.on('success', function(e) {
        let $btn = $(e.trigger);
        $btn.addClass('copied');
        let $icon = $($btn.find('i'));
        $icon.removeClass('ri-file-copy-2-line');
        $icon.addClass('ri-checkbox-circle-line');
        let $span = $($btn.find('span'));
        $span[0].innerText = 'COPIED';
        
        wait(function () { // 等待两秒钟后恢复
          $icon.removeClass('ri-checkbox-circle-line');
          $icon.addClass('ri-file-copy-2-line');
          $span[0].innerText = 'COPY';
        }, 2000);
      });
      clipboard.on('error', function(e) {
        e.clearSelection();
        let $btn = $(e.trigger);
        $btn.addClass('copy-failed');
        let $icon = $($btn.find('i'));
        $icon.removeClass('ri-file-copy-2-line');
        $icon.addClass('ri-time-line');
        let $span = $($btn.find('span'));
        $span[0].innerText = 'COPY FAILED';
        
        wait(function () { // 等待两秒钟后恢复
          $icon.removeClass('ri-time-line');
          $icon.addClass('ri-file-copy-2-line');
          $span[0].innerText = 'COPY';
        }, 2000);
      });
    }
    initCopyCode();
  }(window, document);
</script>
 
<!-- CanvasBackground -->

<script>
  if (window.mermaid) {
    mermaid.initialize({ theme: "forest" });
  }
</script>


    
    

  </div>
</body>

</html>